#### 操作系统的概念

操作系统是一套软件，其管理硬件和软件资源，同时提供与用户交互，是计算机中最基础的一个软件；



#### 特点

- 并发：并发不是两个进程完全同步，而是宏观上是同步的：小渣脚踏两条船，这叫并发；与之类似的概念叫做并行，齐头并进才叫并行；并发能保证多个任务在宏观上能同步运行；
- 共享：共享资源，分为**互斥共享**，比如QQ和微信对摄像头的使用是互斥的；以及**同时共享**，程序对硬盘资源的共享是可以同时的；
- 虚拟：空分复用：虚拟存储，同时开启了多个任务，多个任务的内存相加比实际占用的内存大一些。时分复用，单核CPU在不同的时间执行不同的任务，看起来像是多核，这个叫虚拟处理器
- 异步：任务的执行不是完全按照顺序来的，有可能会中间执行别的任务去；



#### 内核态与用户态

内核态与用户态是CPU的两种状态，CPU中能执行的指令有两种，分别叫做**特权指令和非特权指令**；其中的特权指令是直接直接对内核进行操作的指令，较为底层，通常用户不会直接接触，因为这些指令对与操作系统的影响比较大，不能轻易操作，一般这些指令由**内核程序**给出，内核程序实际上就是操作系统中最核心的部分，众多的内核程序组成了操作系统最基础最核心最必不可少的部分，即为**操作系统的内核**；另外一种指令叫做非特权指令，则是所有用户都能使用CPU来操作的任务，不需要权限，这部分指令主要来源于**应用程序**，与内核程序相对的，应用程序不会涉及操作系统的内核，较为安全。CPU在执行这两种程序时，会处于两种不同的状态，则分别叫做**内核态与用户态**，CPU中存在一个寄存器叫做**程序状态寄存器(PSW)**。由该寄存器来控制CPU处于哪一个状态；

当用户开机时，操作系统需要实现底层的初始化操作，此时CPU处于内核态，允许执行特权指令。当完成了初始化操作，会有一条特权指令来修改程序状态寄存器的状态，将CPU改为用户态，允许执行非特权程序。

假如CPU处于用户态，但是收到了一条特权指令，CPU会直接拒绝执行，并且会**通过硬件**触发中断，强行将用户态转变为内核态，处理相应的中断程序，然后再复位程序状态寄存器，继续执行非特权指令；

**特权指令只有内核态能使用，CPU只有处于内核态才能执行内核指令。**



#### 中断与异常

内核态向用户态过度，需要执行一条特殊的内核指令，而用户态转向内核态的**唯一方法**，只有中断。中断在单片机原理学过。

因为CPU的某条指令，引发的中断，称为内中断；

因为CPU外部的某条信号出发的中断，称为外中断，比如外部计数器或计时器；

比如时钟晶振发出的脉冲信号，让CPU分时复用。假设每次下降沿都会触发中断，将CPU使用权交给内核态，内核态执行一些特权指令，这些指令的目的是将CPU的使用权转移给另外一个应用程序使用；

所以说，**处理操作系统的中断是由特权指令实现的。**

内中断可以理解为执行的程序出了问题，导致CPU强制执行对应的中断程序，那么内中断可以称为**异常**；

而外中断一般是外部给出的中断信号触发的，是为了完成某项既定的中断任务，也可以称为狭义上的中断；



#### 系统调用

操作系统暴露给上层使用的函数接口，函数内部与硬件直接交互，给出接口供上层调用。顶层用户想要使用底层的硬件资源，必须要通多操作系统给出的接口，向操作系统请求硬件资源。比如设备，内存 ，进程，文件创建等。

那么结合上一部分的内容，顶层的某个应用程序，如果需要请求底层的资源，其必须要触发一个内中断，这里的内中断由一条特殊的非特权指令引发，称为**陷入指令**，陷入指令触发的内中断会将CPU置为内核态，同时更具应用程序传入的参数决定具体要执行的是哪一个内核程序，在 内核态执行完相应的特权指令后，还原为用户态，并还原中断现场，并继续执行应用程序。

<img src="C:\Users\18385\AppData\Roaming\Typora\typora-user-images\image-20260105205136374.png" alt="image-20260105205136374" style="zoom:50%;" />

​	

#### 大内核与微内核

前面提到，操作系统中最核心的内核软件构成操作系统的内核，那么哪些才能称为最核心呢？

只保留与硬件交互的部分，这是最必不可少的，以这部分作为内核称为**微内核**；

在微内核基础上，把操作系统的进程管理，存储管理，设备管理等也加进入，这种称为**大内核**



#### 进程

![image-20260106164537565](C:\Users\18385\AppData\Roaming\Typora\typora-user-images\image-20260106164537565.png)

我电脑上有一个程序，程序实际上就是写入硬盘的指令合集。当我要运行这个程序的时候，操作系统会执行以下操作：

- 创建一个独立的进程，用来运行该程序，同时创建一个进程管理模块，管理进程的各项资源，各种信息。实际上就是一个结构体，简称**PCB**；
- 将程序写入内存，称为**程序段**，将数据写入内存，称为数据段；（进程的实体其实就包含PCB，程序段以及数据段)
- 建立好的进程独立使用得到的资源，独立运行。操作系统的多个进程**并发**执行。

**进程只是操作系统中资源分配的最小的基本单位。<font color="red">但不是CPU运行程序的最小单位</font>。在引入线程思想后，线程是一个基本的CPU执行单元，最小单元。<font color="red">内核级线程</font>也是操作系统调度的最小单位**



#### 进程的状态

![image-20260106165701212](C:\Users\18385\AppData\Roaming\Typora\typora-user-images\image-20260106165701212.png)



#### 进程与C++类对象相似

<img src="C:\Users\18385\AppData\Roaming\Typora\typora-user-images\image-20260106171047841.png" alt="image-20260106171047841" style="zoom:67%;" />

<img src="C:\Users\18385\AppData\Roaming\Typora\typora-user-images\image-20260106171102524.png" alt="image-20260106171102524" style="zoom:67%;" />

<img src="C:\Users\18385\AppData\Roaming\Typora\typora-user-images\image-20260106171115845.png" alt="image-20260106171115845" style="zoom:67%;" />

#### 原语

原子性的语句。在操作系统中，每执行一条指令都会例行检查是否收到中断信号，如果检测到中断信号则会触发中断处理程序；但是有些操作需要分为多个指令完成，而且多个指令之间是不允许中断的，这种操作称为**原子性操作**，操作系统为了实现这类原子性操作。有两条特殊的特权指令：关中断检测，和开中断检测。在需要原子操作的指令前，将例行检查中断的操作关闭掉，这样一来后续执行指令后就不会再检测中断信息，确保了指令中间不可中断性；这两条指令都是特权指令，不允许用户操作。



#### :star: 进程间通信

- 共享存储
- 信息传递
- 通道通信
- 信号：任何进程与另外一个进程的通信过程都是一样的，都需要先将信号发送给内核，内核先校验有没有权限修改对方进程的信号，如果校验通过，内核才会去修改对方的信号，如果校验不通过，则不会去修改对方的PCB的pending位图。**信号只会在进程从内核态转换为用户态的时候，例行检查信号位图，然后执行相应的处理。**进程PCB中包含两个位图，分别用来记录信号，以及作为信号掩码，信号掩码会屏蔽位图中特定的若干个位置上的信号。



#### 线程

![image-20260106200816072](C:\Users\18385\AppData\Roaming\Typora\typora-user-images\image-20260106200816072.png)



#### 信号量

信号量与信号是不同的概念，信号是进程控制块PCB中，使用位图保存的数据，用以告知进程需要处理的事务。信号由PCB管理；

信号量则是用来控制进程间同步与互斥的变量，其由操作系统来管理，由进程来申请 ；

信号量小于0，表示资源暂时不可用，进程进入阻塞态；

信号量大于等于0，表示资源可用，进程进入运行态；

- 如果设置初始信号量为1，那么当进程A使用了P操作，申请了资源，信号量变为0；后续如果B也想申请资源，经过P操作后，信号量变为-1，不满足条件，进程B进入阻塞态。**所以设置信号量为1，实现了进程之间的互斥**。
- 如果设置初始信号量为0，进程B想要访问资源时，使用P操作，信号量变为-1，资源不可用，进入阻塞态；等待进程A对资源操作后，使用操作V，将信号量置位1；此时B才能访问。**因此设置信号量为0可以控制进程之间的同步。**



#### 监听

如果想要在主机上运行一个TCP服务器，需要经历以下步骤：创建套接字，将套接字绑定到IP和端口号，监听。这里的监听的实现原理：

- TCP服务实际上也是系统的一个进程，当TCP服务调用监听的时候，操作系统实际上创建了两个队列：半连接队列和全连接队列；
- 一般在监听后都会调用accept函数尝试获取连接，这里的accept是一个阻塞的函数，当调用该函数时，会去全连接队列中拿连接对象，如果空的 ，则进程进入阻塞态；
- 此时，网卡收到了一个连接请求，向CPU发送中断，对连接对象解析后发现目的就是TCP服务的ip和端口号，于是将连接对象移交给半连接队列，这个队列处理SYN，由内核自动发送SYN+ACK；
- 当收到ACK时，内核会把连接转移到全连接队列，此时阻塞的进程就会被CPU唤醒，进入就绪态，时间片到了进入运行态；
- 以上实现一次网络通讯的连接；

监听事件不会导师进程进入阻塞态，只是告知系统，“我要开始营业了”，系统会给其配置相关的队列；

后续的accept才会导致进程进入阻塞态。



#### 生产者-消费者问题

理解互斥与同步经典问题：

现在有一个读程序和一个写程序需要共享操作同一个消息队列，需要哪些信号量？从需求分析：

- 为了避免两个程序同时对资源操作，造成资源错误，需要一个锁或者信号量，来保证两个程序互斥；
- 当共享队列是空的时候，需要保证先执行写程序，再执行读程序，因此需要一个信号量来控制先写后读；
- 当共享队列满了的时候，需要保证先执行读程序，再执行写程序，因此还需要一个信号量来控制先读后写；

总结：需要3个信号量：一个控制队列访问互斥、一个控制队列满时先读后写、一个控制队列空时先写后读。

```c++
semaphore mutex = 1;
semaphore full_mutex = 0;
semaphore empty_mutex = N;

//消费者
void read(){
    while(1){
        P(full_mutex); //读的时候对full_mutex-1，如果当前full_mutex==0，则进程/线程在这里进入阻塞，等待写入
        P(mutex);//操作队列时控制互斥访问
        //具体的数据消费操作
        V(mutex);
        V(empty_mutex);//消费完后，空数量+1
    }
}

//生产者
void write(){
    while(1){
        P(empty_mutex); //写的时候对empty_mutex-1，如果当前empty_mutex==0，则进程/线程在这里进入阻塞，等待消费
        P(mutex);//操作队列时控制互斥访问
        //具体的数据生产操作
        V(mutex);
        V(full_mutex);//消费完后，满数量+1
    }
}
//由于empty_mutex初始值为N，保证了一定时写者最先开始运行；而当队列满后，full_mutex=N，此时保证读程序一定能先运行；
```



#### 哲学界就餐问题

问题描述：有一张圆桌，上面有五个座位，每两个座位之间放了一个叉子。现在五个座位上坐满了 5名哲学家，每位哲学家进餐过程都需要拿到两个叉子。如何让每个哲学家都能顺利完成就餐？

<img src="C:\Users\18385\AppData\Roaming\Typora\typora-user-images\image-20260109163102456.png" alt="image-20260109163102456" style="zoom:50%;" />

问题解析：如果每个哲学家都是先获取左边，再获取右边；那么就会出现一个问题：所有人都拿起了左边的叉子，所有人都在等待右边的叉子，这样一来，所有人都不可能放下手中的叉子，程序进入死锁。所以问题核心在于如何避免死锁。

解决方案：

**方案一**：显而易见，叉子是共享资源，直接加一个全局锁，当其中一个哲学家在使用叉子的时候，其余的人均处于阻塞态；这样一来经过5轮，所有哲学家都能完成就餐。但是5把叉子，按道理每轮能支持两人就餐，全局锁控制了只有一个人能就餐，资源浪费；

**方案二**：死锁形成的逻辑是所有人第一时间都去拿左边的叉子，那如果分开拿呢。奇数位第一时间拿左边叉子，再拿右边叉子；偶数位相反。这样一来：

- 1号位先拿左边，资源存在，成功拿到，再拿右边，资源也存在(1号位第一个执行程序，此时5号位没有执行)，<font color="red">1号位拿到两把叉子</font>；
- 2号位先拿右边，资源被1号位拿走，2号位在这里进入阻塞；
- 3号位先拿左边，资源存在，成功拿到，再拿右边，资源也存在，<font color="red">3号位拿到两把叉子</font>；
- 4号位先拿右边，资源被3号位拿走，4号位在这里进入阻塞；
- 5号位先拿左边，资源被1号位拿走 ，5号位在这里进入阻塞；

所以一轮中有两位拿到了两个叉子进入就餐，实现了资源最大化利用。

**方案三**：使用一个全局数组变量来表示每个哲学家的状态：就绪，就餐，完成。初始值全部均为就绪状态，每个哲学家再就餐前，先查看左右两边的状态，如果存在就餐状态，则进入阻塞；

- 1号位左右两边均为就绪，满足条件，获取左边资源，再获取右边资源，进入就餐状态；
- 2号位右边的1号位为就餐状态，不满足条件，阻塞；
- 3号位左右均为就绪，满足条件，获取左右资源，进入就餐状态；
- 4号位左边为就餐，不满足，阻塞；
- 5号位右边为就餐，不满足，阻塞；

下一轮中：

- 1号位完成就餐，状态为完成，不需要就餐，直接跳过；
- 2号位左右均为完成，满足条件，获取资源，开始就餐；
- 3号位完成就餐，状态为完成，不需要就餐，直接跳过；
- 4号位左边为完成，右边为就绪，满足条件，获取资源开始就餐；
- 5号位左边为就餐，不满足，继续阻塞。



#### 死锁

死锁发生的条件：

- 互斥条件：多个线程不能同时使用同一个资源；
- 持有并等待条件：线程持有一个条件并等待另外一个条件；
- 不可剥夺条件：线程在完成任务之前，手中持有的条件是不可被其他线程剥夺的；
- 环路等待：多个线程获取资源的顺序构成了环路

如何避免死锁：破坏以上任意一个条件即可

- 资源有序获取：让两个线程在获取资源时的顺序一致，都是先获取A，再获取B



#### 互斥锁与自旋锁

- 相同点：两个锁都是用来控制线程对资源的互斥访问的，能确保同一时间只有一个线程会访问指定的资源。
- 不同点：互斥锁处理加锁失败的逻辑为线程切换；而自旋锁处理加锁失败的逻辑为忙等待。

互斥锁：无法获取锁，则阻塞线程。

- 线程A访问资源Q，给互斥锁加锁；
- 线程A还在运行期间，线程B尝试给互斥锁加锁，无法加锁，因为互斥锁已经被加锁；
- 操作系统将线程B置阻塞态，释放CPU资源，保护现场；
- 线程A运行结束，释放互斥锁；
- 操作系统唤醒互斥锁，恢复现场；

可以看到互斥锁在控制互斥访问的过程中，会涉及到线程的上下文切换，会控制操作系统在用户态和内核态之间切换，开销较大；假如线程A运行的时间远小于操作系统对线程B执行两次上下文切换的时间，那么互斥锁会带来额外的时间开销；

自旋锁：无法获取锁，则原地等待（自旋）。

- 线程A访问资源Q，给自旋锁加锁；
- 线程A还在运行期间，线程B尝试给自旋锁加锁，无法加锁，因为自旋锁已经被加锁；
- 线程B进入忙等待，继续持有CPU资源；
- 线程A运行结束，释放自旋锁；
- 线程B忙等待结束，获取到自旋锁，继续执行；

自旋锁在控制互斥访问的过程中，并不会涉及到用户态与内核态的切换，也不会涉及到线程阻塞，对操作系统的开销比较小。但是：自旋锁不会放弃CPU资源，这就导致在单核CPU上，如果不借助外部时钟对CPU进行分时复用，则持有自旋锁的线程会一直占据CPU。根据其特性，如果被锁任务的执行时间短于两次用户态到内核态的上下文切换时间，使用自旋锁比使用互斥锁更加高效。

综上：**如果等待时间较长，使用互斥锁；等待时间较短，使用自旋锁**。



#### 读写锁

读锁允许多个线程同时持有锁，写锁在同一时间只允许一个线程持有写锁。

#### 悲观锁与乐观锁

悲观锁认为多个线程操作同一个资源时，发生冲突的概率很高，所以必须要先控制互斥，再允许访问；

乐观锁认为多个线程操作同一个资源时，发生冲突的概率很低，所以不需要管，直接允许线程操作资源，但是再操作完保存资源的时候，再检查是否冲突，如果有冲突则保存失败。如果无冲突，则保存成功。但是，一旦冲突概率较大，便不适合乐观锁，因为解决冲突的成本较大。比如共享文档，Git都是属于乐观锁。