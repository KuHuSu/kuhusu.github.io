##### 1、std标准库中的sort函数使用的排序方法是什么？

- 主要是快速排序，同时也使用了插入排序和堆排序进行优化。根据源码中即可得出，快排递归到子数组长度低于一个临界值_ISORT_MAX之后，采用插入排序加速，因为快排的过程中数组会逐渐趋于有序，插入排序的优势很大，这个临界值一般设定为32；每次递归时还会进行一个深度计算，快速排序的最优递归深度应该为$log_2{n}$，当当前的深度超过$1.5*log_2{n}$时，对当前子数组采用堆排序。当层数超过这个限制时，子数组本身的元素数量也不会太多，堆排序不需要使用递归，且相比于其他排序算法的时间缺失并不会太明显，但是该算法能显著的节省空间。

  ```c++
  _INLINE_VAR constexpr int _ISORT_MAX = 32; // maximum size for insertion sort
  ```

  ```c++
  if (_Last - _First <= _ISORT_MAX) { // small
      _STD _Insertion_sort_unchecked(_First, _Last, _Pred);
      return;
  }
  
  //为什么这里不使用插入排序呢？能使用的情况应该在上面那行就进入了，哪里还会轮到这里
  if (_Ideal <= 0) { // heap sort if too many divisions
      _STD _Make_heap_unchecked(_First, _Last, _Pred);
      _STD _Sort_heap_unchecked(_First, _Last, _Pred);
      return;
  }
  
  _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
  ```

##### 2、如何解决快排的复杂度恶化问题？

- 首先需要明确，为什么会出现复杂度恶化？快排的数组如果本身就趋于有序，选择去第一项作为基准数时，会使得二叉树的分布偏向某一边，使得二叉树的深度不断加深，退化为冒泡排序。为解决这个问题，有两个方案：
  - 结合插入排序：快排的执行过程中会使得数据逐渐趋于有序，当子数组长度小于某个界现时，改用插入排序可以有效提升速度，避免不必要的递归；
  - 取用数组中间位置的数作为基准数：对于明显乱序数组，取用哪个数做基准数都无所谓，但是对于趋于有序的数组，中间位置的数更有机会使得二叉树的左右分布均匀，避免复杂度恶化；

##### 3、 如何解决快排递归过深的问题？

- 借鉴标准库，使用一个变量来控制递归的层次，当递归层数到达指定阈值后改用其他非递归的排序方法，建议使用堆排序。（标准库中为什么不使用希尔和插排？：代码能执行到这里说明长度没有达到插排的下限，而这俩存在一个最坏时间复杂度$n^2$，避免出现这种最坏情况，改用复杂度比较稳定的堆排序才是最优解）

##### 4、什么叫内排序，什么叫外排序，哪种算法能支持外排序？

- 内排序：数据全部在内存上操作的排序方法称为内排序。冒泡，选择，插排，希尔，快排，堆排均为内排序；
- 外排序：数据无法全部加载到内存上，需要借助磁盘实现的排序称为外排序。归并排序支持外排序。
  - 归并排序是一种明显的分治思想，如果数据无法一次加载到内存上，可以直接把原数组切割为若干个小片段，即人为将数组切割为归并的中间某层。

##### 5、假设有100Mb的内存空间，想要对1Gb的数据进行排序？

- 答案为**归并排序**。可能有点反直接，归并排序的空间复杂度是最大的，明明空间就不够了，为什么还要使用归并呢？归并排序能排，但是速度还会比较慢，因为归并排序是一种外排序，其分治排序的思想使得可以借助磁盘存储每个分片的排序结果。

