#### 	二分搜索

- 时间复杂度：$log_{2}n$。怎么来的？ =》 折半查询的最终目的是逐步减小查询区间，最极限的情况下，会将区间减小到1。时间复杂度通俗说法就是程序内部的循环次数。最开始的查询区间为$n$，接着为$\frac{n}{2}$，再继续为$\frac{n}{2^2}$，$\frac{n}{2^3}$，$\frac{n}{2^4}$，$\frac{n}{2^5}$，…… ,$\frac{n}{2^k}$。极限情况下假设需要循环k次才能出循环。那么就有$\frac{n}{2^k} \rightarrow 1$。极限情况取$\frac{n}{2^k} = 1$，即可得到$k = log_{2}n$，即循环次数为$log_{2}n$次，用以衡量时间复杂度。	
- 时间复杂度：另外一种解释：二分查找实际上就是将有序数组视作是一个**完全二叉树**，最极限的寻找过程实际上就是需要这个树的每一层都要访问一次，也就是求这个完全二叉树的层数。那么问题就转换为了具有n个结点的完全二叉树的层数问题。根据完全二叉树的**性质：具有n个结点的完全二叉树的深度为$\downharpoonright  \log_{2}n \downharpoonleft +1$。（不大于$log_{2}n$的最大整数+1）**。直接就能得出时间复杂度。

#### 排序:star:

- 以下均以从小到大排序为例；

- 排序的稳定性：在一个数组中如果有多个相同的元素，经过排序算法后，这几个相同元素的相对位置是否发生了改变。**如果相对位置发生变化，则为不稳定；如果相对位置没有产生变化，则为稳定**；

| 排序方法           | 时间复杂度                                        | 空间复杂度              | 稳定性 | 补充                                 |
| ------------------ | ------------------------------------------------- | ----------------------- | ------ | ------------------------------------ |
| [冒泡排序](#part1) | 最优$n$，最差$n^2$，平均$n^2$                     | const                   | 稳定   | 过多的交换，**速度最慢**             |
| [选择排序](#part2) | 最优$n^2$，最差$n^2$，平均$n^2$                   | const                   | 不稳定 | 过多的比较，**速度较慢**             |
| [插入排序](#part3) | 最优$n$，最差$n^2$，平均$n^2$                     | const                   | 稳定   | 比较次数少，没有交换，**速度快**     |
| [希尔排序](#part4) | 最优$n$，最差$n^2$，平均$n^{1.3}$                 | const                   | 不稳定 |                                      |
| [快速排序](#part5) | 最优$nlog_{2}n$，最差$n^2$，平均$nlog_{2}n$       | 最优$log_{2}n$，最差$n$ | 不稳定 | 数组已经趋于有序，退化为冒泡排序     |
| [归并排序](#part6) | 最优$nlog_{2}n$，最差$nlog_{2}n$，平均$nlog_{2}n$ | o(n)                    | 稳定   | 左右部分之间不存在交换，稳定         |
| [堆排序](#part7)   | 最优$nlog_{2}n$，最差$nlog_{2}n$，平均$nlog_{2}n$ | const                   | 不稳定 |                                      |
| [基数排序](#part8) | 最优$nd$，最差$nd$，平均$nd$                      | o(n)                    | 稳定   | d为最长元素位数，需要借助一个n维数组 |

##### <span id="part1">冒泡排序</span>

- 遍历数组，每次都比较相邻的两个元素，如果前一个元素大于后一个元素，则交换这两个。意味着每一次交换，都会将局部最大值往后移，经过一轮遍历后，数组中最大的那个值会就会被移到数组末尾。第二轮在使用同样的方法遍历除了最后一位的剩余数组，同样也会将前n-1个元素的数组中的	最大值沉底；每一轮都会将最大值移到末尾，像是冒泡泡一样。
- 简单说就是：如果从前往后遍历，每轮循环都要将最大值放到末尾；如果从后往前遍历，每轮都要将最小值移到头部；

##### <span id="part2">选择排序</span>

- 同样需要遍历数组，类似于冒泡排序。冒泡排序从尾部开始遍历与选择排序从头部开始遍历，每一轮结束后的数组是一致的。选择排序跟冒泡排序其实最底层思想是一致的，都是将局部的最小值移动到指定位置来。冒泡排序采用的方法是，将最小值一层一层往上交换；而选择排序的方案是先找到局部最小值，再直接交换。从以上描述也能得出：选择排序实际上就是冒泡排序的优化版，省略掉了很多不必要的交换，减少了运算时间。
- 选择排序是一种**不稳定**的排序算法：65，65，65，25，24，23。经过排序算法之后，前面相同的3个数据显然位次会恰好颠倒。

##### <span id="part3">插入排序</span>

- 假设当前位置的前面的序列已经是有序的，那么直接将当前值插入到前面有序序列中的对应位置即可。算法梗概：
  - 算法假设第一个元素已经是有序的；
  - 从第二个元素开始，从后往前遍历当前位置的前面的序列，找到第一个小于当前值的元素，将当前值**插入**到其后边即可；
- 误区：名字叫做插入排序，如果但是实际上其**执行过程并不是严格意义上的插入，而是覆盖**。当判断到某个元素大于等于当前元素时，同步就将该元素覆盖到后一个位置上。避免了在数组中插入数据(数组插入数据的时间复杂度为n)；
- 插入排序在比较时，并不一定需要将前面的所有数字全部遍历一遍，其比较次数是明显少于选择排序的；而且插入排序中不存在交换操作，而是直接覆盖；从这两个点可以看出插入排序的性能优于选择排序。
- **如果数据趋于有序，那么插入排序是所有排序算法中速度最快的算法。**

##### <span id="part4">希尔排序</span>

- 插入排序有一个特点：**如果数据趋于有序，那么插入排序是所有排序算法中速度最快的算法。**那么如果能使数组整体上趋于有序，再进行排序，那么排序的速度将会得到显著的提升。希尔排序就以这样的思想，来对插入排序进行优化。
- 希尔排序的目的就是在原有数组的基础上，让其整体缓慢趋于有序。即给定一个距离gap，每隔gap取一个元素组成一个新的数组，然后**在原有位置**上，分别对每个子数组做插入排序。然后逐渐减小gap，直到最终的gap到达1。当gap到达1的时候，其实整个数组经过上述的调整后，整体已经呈现出一个比较有序的状态，此时最后一轮的插入排序将极大缩减时间。
- 41 80 3 10 11 3 65 35 78 89  分组=>  <font color="red"> 41</font> 80 <font color="red">3</font> 10 <font color="red">11</font> 3 <font color="red">65 </font>35 <font color="red">78</font> 89  分组插排=> <font color="red">3</font> 3 <font color="red">11</font> 10 <font color="red">41</font> 35 <font color="red">65 </font>80 <font color="red">78</font> 89 。可以看到，经过分组排序之后，虽然整体上并没有完全实现排序，但是相比于最开始的状态，整个数组中无序元素已经较少了，此时再使用插排，只需要将35和78这两个元素移动即可完成排序。

以上的排序算法均属于基础排序算法，**使用计时模块计算四种算法对一个长为50000的数组排序时的时间损耗**：

![image-20250924201535668](/notes_images/image-20250924201535668.png)

:star:（需要注意的是，写这样的测试时，由于数组较大，不宜直接使用`int[50000]`声明变量，这样的声明的变量在栈上，容易造成溢出。应该使用malloc或者new在堆上开辟空间）

可以看到希尔排序的速度是冒泡排序的100多倍，是基础插入排序的20倍。希尔排序在中小型规模的数组排序场景中（10万以下）已经完全够用。

##### <span id="part5">快速排序</span>

- 快速排序的思路为选择数列的首元素为基准线，将小于基准线的数据移动到基准线左侧，大于基准线的数据移动到基准线右侧。
- 以上的操作视作一轮，在经过一轮后，基准点左侧全部小于基准点，右侧全部大于基准点；
- 再分别对基准点左侧和右侧分别做上述操作；
- 以上1、3不断递归。最终使序列有序。
- 快速排序的时间复杂度主要为两方面：其一是使用快速排序分组的次数，这个次数即为二叉树的深度，即为$log_{2}n$，也就是最外层循环次数；其二即为内层比较的次数，即为数组长度n，所以时间复杂度为$nlog_{2}n$；而当数组已经是完全有序的情况下，二叉树永远只有半支，且每一层只在上一层基础上数据减1，因此，二叉树深度为n，因此时间复杂度即为n平方。
- 快速排序的空间复杂度主要来源于函数递归时所占用的内存栈数量。实际上即为二叉树的深度，通过上面的分析即可得出最优为$log_{2}n$，最差为n。
- **快速排序的优化**
  - 上面提到，如果数据已经趋于有序，则快速排序会退化为冒泡排序，为了应对这样的情况，提出以下两种优化方案：
    1. 设定一个阈值，当递归传入的数据长度小于该阈值时，直接采用插入排序，因为随着快排的深入，数据应该会越来越有序，快排对于趋于有序的数组的性能不如插排。
    2. 对于一个趋于有序的数组，其时间复杂度退化为冒泡的原因在于，基准数的选取过于极端，恰好选择到了数组中的极值才导致的复杂度退化。那如果选择基准值时，使用数组中间的元素作为基准值，会有效避免这样的情况：**因为对于完全无序的数组，基准值选哪个都无所谓，而对于趋于有序的数组，选择中央区域的元素，极大概率能选到中值附近的元素，能提升性能。**

##### <span id="part6">归并排序</span>

- 归并排序中的“归”即为递归的“归”，意思即为在递归返回的过程中实现排序；
- 排序中的递归都是逐级二分，分别处理的，其逻辑与快速排序存在相似之处。快速排序是在递之前，按照一个基准数将数组划分成左右两半，然后二分传递；而归并是先传递，然后再归的时候比较两个子数字，按子数组的位实现排序；
- 

##### <span id="part7">堆排序</span>

- 堆排序需要使用二叉树的数据结构：大根堆与小根堆的思想。大根堆和小根堆可实现优先队列，在入堆时从末尾位置插入一个元素，然后将末尾元素上浮至恰当位置，保证大根堆或者小根堆的整体结构；出堆时则从堆顶元素开始出堆，每次出掉一个堆顶元素后，从堆尾提取一个补到堆顶，实现下沉；利用此思路可以实现优先队列的数据类型；
- 堆排序的输入是一个乱序的数组，直接在数组上操作即可实现堆排序。分为以下两个步骤：
  - 数组调整：需要将数组调整为大根堆或者小根堆；从第一个非叶子节点开始调整：先处理下游的叶子节点，再处理上游的父节点，按照大/小根堆中父节点与子节点之间的关系调整。
  - 将堆顶元素交换到堆尾，然后使用前n-1个元素实现堆的下沉；也就是将顶部取出来，暂存在尾部，其余的部分重新推举根节点。
  - 遍历完所有堆顶后，数组就能变成有序的；
- 以大根堆和小根堆实现优先级队列：
  - 大根堆可以实现**由大到小**的优先队列；小根堆可以实现由小到大的优先级队列；
  - 因为优先队列每次出堆都是将堆顶取出，则每次都取出当前最大值，因此顺序为由大到小；
- 以大根堆和小根堆实现堆排序：
  - 大根堆可以实现**由小到大**的排序；小根堆可以实现由大到小的排序；
  - 因为大根堆在原地操作时，是将堆顶元素陆续插入到队尾，最终队尾到队首为从大到小，整个数组正向即为由小到大；

##### 堆排序vs快排vs归并

这三种排序方法的时间复杂度最优均为$nlog_{2}n$，但是相比于其他两种排序的实际时间花销，堆排序往往花费的时间会更多，主要原因有以下两点：

- **CPU的读取缓存机制**：CPU在处理具体某一条指令或者数据时，并不仅仅是所指向的内存写入缓存中。在实际执行指令或者操作数据时，当读取了某个地址的数据后，下一个读取相邻内存数据的概率非常大，于是为了CPU的性能考虑，在执行指令或者操作数据的时候会将相邻的内存单元一并写入缓存，加速下一回合的操作。快排和归并排序中，都是按照内存顺序操作数组中的元素，符合CPU的缓存读取机制；而在堆排序中，内存的读取和操作是跳跃的，内存空间并不相邻，因此每次操作一个数据时，都需要先从内存中读取，再操作，拖延了速度；
- **太多无效的替换和比较**：在堆排序中，出堆时需要执行堆的下沉操作，该操作中会将堆尾部的最后一个元素移动到根节点，然后再将根结点逐级比较下沉。但是堆尾的元素一般比较小，将其移动到堆首，再继续下沉，大概率会把9成的层级全部比较一遍 ，然后沉底。每一次出堆都会执行一轮该操作，尽管沉底后的位置相对于原来的位置，可能就差一层，但是却要经过前面所有层的比较。因此额外耗费了时间。

![image-20251112194205771](/notes_images/image-20251112194205771.png)

- **堆排的意义何在**？堆排序相对于其他两种排序存在时间上的劣势，但是该方法胜在**稳定**。快排存在复杂度恶化的情况，即数组趋于有序，无论正序还是逆序。归并的时间复杂度与堆排一样，但是其占用的空间复杂度远大于堆排。可以说这归并和堆排五五开，各有优劣；大部分情况下快排性能更优，但快排也会出现极端情况导致性能远低于其余两种方法。

##### <span id="part8">基数排序</span>

基数排序另外一个名称叫做桶排序。创建一个长度为10的二维数组，首先以数据的各位为数组下标将数据放入数组中，然后再以十位为数组下标将数据放入数组，直到将最大的那个元素的位数也涵盖之后，取出的数据即为有序。

核心思想就是利用”数组的下标是天然有序的“这一特性，直接将元素的值与数组的下标挂钩，直接不需要任何比较即可借助数组下标自动实现排序。这就好像是先把元素一个个放到对应的桶里再拿出，所以又叫桶排序。

- 优点：没有比较，且时间复杂度稳定，最好、最坏、平均均为$o(nd)$，n为元素个数，d为最长元素的个数；
- 缺点：利用了数组下标排序，但是数组下标只能是非负整数，因此适用范围受限，最适合的场景为正整数排序，其他场景都需要额外的操作。