####  数组

- 数组的优点：
  - 下标**访问**和随机**访问**，时间复杂度很低，都是常量级；
  - 末尾增减元素的时间复杂度很低，常量级；
  - 访问指定元素的前后元素很方便；
- 数组的缺点：
  - 非末尾插入数据，时间复杂度高，线性级；
  - 搜索的时间复杂度高：**但并不是都高，看是否有序**
    - **无序**数组的时间复杂度为线性级；
    - **有序**数组的时间复杂度为对数级（二分查找）；
- 数组扩容三步：
  - 开辟更大的内存；
  - 拷贝原有的数据；
  - 释放原有的内存；
- 数组尾部增加元素的时间复杂度多大？
  - 【错】O(1)时间复杂度；
  - 【对】O(1)或者O(n)，如果当前数组没有达到上限，则末尾新增元素的时间复杂度为O(1)，但是如果数组达到上限了，则需要扩容，扩容中涉及到数组的拷贝，时间复杂度为O(n)；
- 数组插入和删除的时间复杂度多大？这个也最好将末尾元素单独拎出来，末尾新增和删除的时间复杂度为O(1)其余位置为O(n)；
- **数组作为函数参数传递**：当函数的入参中传入一个数组时，实际上传递进去的是一个指针，称为数组作为入参会退化为指针。指针指向的是数组的头部，如果退化为指针，则会丢失掉长度信息，因此一般将数组作为参数传递时，附带上一个长度传入。

#### 双指针

顾名思义就是在一个数组中用两个指针指向不同的数据，只进行一次遍历就能在本地实现某些操作。

- 判断数据奇偶性的方法：

  - 常用方法：使用取模为0和为1来判断，为0则是偶数，为1则是奇数；

  - 较快方法：使用位计算，因为计算机中的数据存储方式就是字节存储，所以直接按位与。奇数的二进制最低为必然是1，偶数的二进制最低位必然是0。所以，直接将数据与0x01求与操作就能判断奇数和偶数：

    ```c++
    (n & 0x01) == 0 说明为偶数；
    (n & 0x01) == 1 说明为奇数；
    ```

    位操作的优先级比==优先级低，所以位操作必须要添加括号。

#### 链表

- 链表的每一个节点都是在堆上开辟的，节点的实际内存地址不能保证连续；

- 链表使用指针量表示，注意区分链表节点和next节点；

- 头结点和首节点：头结点时链表中首个数据节点的前一个 节点，单纯用于标志首节点地址的；首节点是链表中的第一个包含数据的节点；

- 链表析构时：既然都要把整个链表全删干净，那么头结点的位置也就无关紧要了，**在这个过程中头结点只是一个指针**。所以可以直接利用起来，结合另外一个指针，构成双指针，按顺序析构整个链表。不需要再申请额外的内存开销了。

- 链表的插入和删除：单论插入这个操作以及删除这个操作而言，这两个操作的时间复杂度都是O(1)，这里特指的仅仅是这两个操作。但是在实现的过程中，还需要使用查询来辅助，查询的时间复杂度为O(n)。

- **析构函数注意事项**：当程序结束时，程序会自动调用析构函数。现在有这么一个问题：

  :star2: 我有两个单向链表A和B，现在我将B合并到了A上。那么请问在程序中需不需要将B的头结点地址域置空呢？

  :star: 回答：**必须置空**。因为如果将A和B原地合并了，即将B中的每个节点都链接到了A上。那么将存在两个指针同时指向B链表的首节点：A中合并后该节点的上一个节点以及B的头节点。当程序结束了，程序自动调用析构函数时，由于链表的链式析构，该节点将会被析构两次。A链表在析构时，该节点的地址已经被程序析构了。那么当B链表析构到该节点时，该节点实际上已经不存在了。会造成重复析构。(**非常容易被忽略且该问题编程语言无法自动解决，只能超时弹出**,)



#### 双向链表的删除

原理很简单，对于某个指定删除的节点，删除过程如下：

1. 首先找到该节点；
2. 记录其下一个节点；
3. 将前一个节点的next域置为其下一个节点；
4. 将后一个节点的pre域置为其前一个节点；
5. 删除该节点即可；

原理非常简单移动易懂，但是容易忽略掉一个点：删除节点的后继不一定存在节点，即有可能删除节点为末尾节点。在该种情况下，不能对其后继节点的pre赋值，因为不存在。

所以步骤4应该修改为：4. 如果其后一个节点不为空节点，则将其后一个节点的pre域置为其前一个节点；如果为空，则不需要额外操作。



#### 野指针（悬挂指针）

野指针是指在程序运行中指向了一个无效地址的指针，即指针指向的空间已经被内存管理器释放了，或者说还没有初始化。其主要来源有以下几类：

1. **指针未初始化**：局部指针变量在声明后没有初始化，则其指向的空间是一个随机垃圾值，该空间有可能在其初始化后被分配给某些任务；
2. **指针内存释放掉后未置空**：delete释放一个指针，只是释放了其指向的内存空间，指针本身还是存在的。这也是为什么在`delete p`之后还能继续对p赋值操作的原因。**但是这样的指针有可能导致系统崩溃等严重问题**。
   - 例1：在主函数中调用了一个函数，入参为一个指针p的引用。在函数内部，使用delete释放了指针p指向的内存。此时指针p仍然存在，而在主函数结束时，系统会自动释放掉主函数中的内存空间，系统判断指针p不为空，则会尝试释放掉p指向的内存空间，即**内存的重复释放**。在函数释放掉p的内存后，系统会将被释放掉的那部分内存标注为可分配状态，如果在主函数没有结束前，这块内存被其他线程使用了，存入了某些数据，而在主函数结束时，系统将该部分数据给释放掉了，就会依赖该内存数据的线程出现问题，如果该内存被操作系统使用了，这样的重复释放可能会导致系统崩溃。
   - 例2：多线程任务中，如果多个线程共享某个指针，当其中一个线程结束后，调用delete释放了内存，而其他线程并不知道，可能会重复多次尝试释放内存。如上。
3. **访问越界**：这个好理解，如果有一个数组a占用1\~10这部分内存，而当该部分内存被分配给a后，紧接着就将11\~20分配给另外一个数组b了。当数组越界操作数据时，可能会导致依赖b的线程崩溃；
4. **返回局部变量地址**：C++中局部变量的生命周期在局部函数结束时会自动收回，在离开局部函数时，函数中的局部变量的内存空间实际上已经没有意义了，会被系统分配给其他任务。倘若将局部变量的地址返回，并尝试在后续的主函数中操作该内存，可能会导致严重的程序问题。

基于以上描述，野指针的存在并不明显，因为变量的释放在程序结束时会自动完成，其并不会判断内存是否有效。但是对野指针的操作严重会导致系统问题。为了避免以上问题，需要养成一些 良好的编程习惯：

- **指针的声明直接置空：**`int* p= nullptr;`
- **delete和置空成对出现：**`delete p; p= nullptr;`但是注意：如果在函数内部定义了一个局部变量p等于入参，后续对p进行delete操作后，不需要置空，因为函数局部变量在函数结束时会自动收回。即**需要手动置空的为new手动申请的内存**。
- **严格控制指针作用域。**
- 使用智能指针，自动管理内存。(这个还没学)



#### 栈

- 一个很形象的比喻：**栈就是一个弹夹**。先进后出。
- 栈的实现可以选择顺序结构，比如数组实现。但是只要接触数组就必须要考虑一个重要问题：**数组越界问题**
  - 栈顶增加元素时，考虑数组的容量；
  - 栈顶访问元素时，考虑栈不为空；
- 顺序栈：数组的头部作为栈底，尾部作为栈顶
- 链式栈：链表的第一个节点为栈顶，最后一个节点为栈底
- 整数除法的截断：**向零截断**。C++中的整数除法默认会向最接近0的方向取整。



#### 后缀表达式

- 中缀表达式：这里的“表达式”指的是一个运算表达式中数据和运算符的相对位置。如果运算符在操作数中间，则称为**中缀表达式**，这是我们数学中使用的表达式，其优点就是**易于人类理解**。即：1+2，2+3\*4等。但是并不易于机器理解，因为中缀表达式中存在逻辑运算的先后次序，而这些运算次序是由我们人为规定的，计算机读取数据时顺序读取，而计算顺序却不一定是顺序计算，比如2+3\*4中，计算机读取到3时，并不能直接与2相加，因为乘法优先级大于加法，应该先等待后边的乘法计算完后才能计算加法，这就给计算机增加一层额外的判断量，容易引入歧义。
- 前缀表达式：如果把运算符提取到运算数前面，则称为**前缀表达式**，又称**波兰表达式**。前缀表达式在读取到运算符后开始运算，运算数字为运算符后两个数，在计算机顺序读取的过程中，即可完成运算，不需要额外的括号来辅助修正其运算顺序，比如+*342对应2+3\*4。在计算机中实现该计算，需要使用递归算法，当运算过长时，多级递归会导致性能降低；
- 后缀表达式：顾名思义，运算符在运算数据的后边，又称**逆波兰表达式**，这是计算机中常用的计算方法，因为运算符在后边，则运算符前面的数据就可以存入栈中，在顺序读取的过程中就能完成计算，同样可以避免不必要的免麻烦.
- 后缀表达式如何计算：
  1. 按顺序入栈；
  2. 如果为操作数，则直接入栈；
  3. 如果为操作符则取出栈顶元素作为操作符右侧操作数，再取出栈顶作为左侧操作数，执行操作，将值入栈；
  4. 遍历每一个元素，最终的栈顶元素即为计算结果。

#### 队列

- 队列的数组实现：
  - 直接使用数组实现：队列头部正在不断新增，尾部在不断移除。但是由于数组的存储结构，导致被移除的空间无法利用，空间利用率较低；
  - 环形数组：数组本身不能作为环形，但是可以使用逻辑使其呈现环形的特征：当数组遍历到最后一位之后，自动返回数组的头部。**对遍历的迭代器做取模操作即可**。
- 队列满和队列空：
  - 队列空：即初始化时的队列状态，当前位置等于头部位置时，说明队列为空；
  - 队列满：在环型队列中，可以想象如果队列被完全塞满了，那么此时的位置也是等于头部位置，这样的判断条件与队列空的条件就完全一致了，无法区分；因此为了区分两种状态，默认队列的最后一个空间保留，当满足当前位置的下一个位置等于头部时，即表明队列满了。因此，**环形队列满≠所有空间都有数据**：队列的最后一个位置是空的(或者数据无效)。

#### 环

- 算法中实现环形的数据结构，第一反应想到的是使用链表，因为链表的实际存储区域并不一定是连续的，其连接方式取决于节点中的指针域，只需要将末尾节点的指针域赋值为头节点，即可实现环形的数据结构；
- 另外一种方法，可以使用数组实现环形队列；数组的地址空间在物理上是连续的，也不存在指针域。要使其呈现环形的结构，只能在逻辑上实现；对索引进行取模运算，即可在索引到达尾部之后，自动还原到头部，从而实现逻辑上的回环；
- **取模运算可以从逻辑上实现回环**。

