[TOC]

#### 一、数据结构

##### 1、线性表

n个元素的有序列，元素与元素之间存在唯一的前后逻辑关系。

- **顺序存储结构**：表中的每个元素，其在物理空间中的存储位置是紧紧相邻的。表在创建之初会分配其开始的地址，而后其余元素的访问以及插入，都可以使用基于初始地址的偏移量来实现。只要给定一个偏移量，就能定位到指定的元素中。这样的存储结构的特点是**随机存取**。
  - 优点：对于操作人员来说，便于访问，简单易使用；
  - 缺点：对于操作系统而言，表中元素的插入和删除都需要移动大量的元素，操作复杂**。**
- **链式存储结构**：逻辑上呈顺序关系的一组元素，其在物理空间上的存储位置是可以不相邻的。为了实现这种存储方式，则在存储数据时，除了数据本身，还需要额外添加一个体现顺序的数据。也就是同一个物理空间需要被划分为两个部分，第一部分用于存储数据本身，称为**数据域**，第二部分用于存储按照顺序来说，其下一个物理存储空间的地址信息，称为**指针域**。链式存储结构中的一个元素称为一个**结点**。
  - 静态链表：根据链式存储结构的逻辑思路，可以使用顺序存储结构的线性表来模拟这种存储结构。即，线性存储结构中的每一个元素都是一个结构体，结构体中包含至少两个元素，其中包含一项数据本身以及至少一项下一个结点的地址(或者索引)信息。这种没有利用链式物理空间的模拟的链式存储，成为**静态链表**。
  - 单向链表：链表中的每个节点有且仅有一个指针域，指向下一个结点的地址。整个链表的地址由头结点的地址决定，链表的最后一个结点的指针域为空。
    - 如果想要访问其中第n项元素的值，就不能直接按照相对头结点地址的偏移量来查询，因为每个结点的数据存储空间在物理地址上是不连续的，没有强制性顺序关系的。而需要从头指针开始，不断的访问下一个，直到计数达到指定的索引次数，即为索引处的数据值。也就说，链式结构的数据访问并不能直接锁定到指定位置，这种结构为**非随机存储结构**。
    - 另一方面，如果想要往链表中插入数据，或者从链表中删除结点，在物理空间上不需要移动任何一个空间中的数据。因为<u>链式结构的顺序是由结点中的指针域决定的，与物理空间无关</u>。插入时，只需要将待插入的数据的物理存储地址插入到链表中即可：插入位置上一个结点的指针指向待插入结点的地址，待插入结点的指针指向插入位置下一个结点的地址。删除时，只需要将待删除位置的上一个结点的指针指向待删除位置的下一个结点地址，然后清空待删除结点的物理空间中的数据即可。在链式存储结构中的数据插入和删除，有效的避免了顺序存储结构中的大量数据物理空间的移动。
  - 循环列表：顾名思义，就是将单向链表的尾结点的指针指向头结点地址即可。
    - 循环指针可以有效降低某些操作的时间复杂度，比如合并链表。对于两个单向链表，如果要合并为一个单向链表，则需要其中一个链表从头指针开始寻找，找到尾结点，然后将尾结点的指针指向另外一个链表的头结点的地址，实现过程需要遍历整个链表，时间复杂度为O(n)。而对于循环链表，若只设定尾指针，在合并链表时，只需要将两个尾指针指向结点的指针互相交换即可，时间复杂度为O(1)。
  - 双向链表：在单向链表中，从某个位置出发，如果想要查询其之后第i个位置的数据，则时间复杂度与i成正比，而无法查看其上一个位置的数据。循环链表中可以查看上一个位置的数据，但是必须要循环n-i次，时间复杂度为O(n)。双向链表则是在单向链表的基础上，在其指针域中再添加一项指向其上一个结点，那么从任意位置出发，都能轻易的往前和往后查询数据。

##### 2、栈和队列

如果按照数据在物理空间中的存储特点来看，顺序表可以分为以上的顺序存储和链式存储。从另外一个维度来看，按照数据增删的逻辑来看，还可以分为堆栈和队列：

- 栈：栈是一种Last In First Out的顺序表，规定栈中的元素都是先入后出。栈也是一种顺序表，表头称为栈底，表尾称为栈顶，元素进入栈内都需要从栈顶进入，而从栈中取出元素时也必须先从栈顶取出。

  栈的实现可以使用顺序存储结构，在该种类型中：

  - push：一般向栈顶中增加元素的操作称为push；
  - pop：从栈中取出元素的操作称为pop；
  - 栈的初始化过程中需要指定栈底和栈顶的地址，使用地址指针指定。初始的空栈栈顶指针等于栈顶指针，后续有元素入栈时，栈底指针不变，栈顶指针+1，**栈顶指针永远指向栈顶元素的下一个位置**；

- 栈应用：

- ```c++
  1、数制转换，10进制转换为8进制，数学算法为循环不断取余，最开始算出的余数为最低位，最后算出的为最高位。则可以利用堆栈的特性保存每次计算出来的余数，然后再从栈顶开始依次输出即可。
  2、括号匹配检验：[{()[]}]是合法的括号书写方法，[(])是不合法的书写方法，检验一个表达式中的括号是否都合格，可以使用堆栈。依次读取表达式中的字符，若为左括号，则入栈，若为右括号，则于当前栈顶的元素匹配，如果两者匹配，则移除栈顶元素，同时读取下一个字符。以此循环类推。如果中间某一环节读取字符于栈顶不匹配或者字符读取完后栈中仍然有元素则说明，括号数学方法存在错误。
  3、
  ```

  

- 

##### 3、矩阵

- 稀疏因子：假设再一个m×n的矩阵中，总共包含t个元素**不为零**，则可以$\delta = \dfrac{t}{m*n}$为矩阵的稀疏因子，通常认为$\delta \leq 0.0.5$时的矩阵为**稀疏矩阵**。
- 矩阵的压缩：矩阵在计算机中的存储可以按照列为主序存储，也可以按照行为主序存储。对于m×n的矩阵，正常需要m×n个存储单元，这种情况对于矩阵中大部分数据有效时，存储空间是必须的。但是对于一些特殊矩阵，比如对称矩阵，下(上)三角矩阵，对角矩阵等。这类矩阵中的数据具备一定的规律，存在大量的重复项或者零值，如果仍然按照m×n的空间来存储，则会浪费很多空间。因此这类矩阵的存储可以适当的压缩：
  - 对于特殊矩阵，一般只存有效元或者只存一半；
  - 对于稀疏矩阵，则需要改变存储方式，由原先的顺序存储矩阵元素改为存储矩阵元素以及位置信息。

##### 4、树与森林

- 结点的度：指的是某个结点包含的子树的数量；

- 结点的层次：从根结点到指定结点总共包含的层级次数；

- 树的度：树中所有结点的度的最大值；

- 树的深度：树中结点的最大层次；

- 二叉树：树中每个结点的至多只能有两个子树，并且子树有左右次序之分。

  - **性质1**：在二叉树的第i层上，最多有$2^{i-1}$个结点。（从1开始的等比数列，指数递增）

  - **性质2**：深度为k的二叉树，其中包含的结点数最多为$2^{k}-1$。（等比数列的和）

    1. 一颗深度为k，且结点数为$2^{k}-1$的二叉树称为**满二叉树**。
    2. 满二叉树可视作深度为k的二叉树的最完整的模板，对于该模板可以对每个结点编号，自上而下，从左到右依次编号。
    3. 一颗深度为k，结点数为n的二叉树，对其编号，如果编号后，如果该树中每个编号都与其对应的满二叉树中的对应位置的编号一致，则称此类二叉树为**完全二叉树**。也就是相对于满二叉树，完全二叉树只能在最深的一层，从右到左依次存在缺失。
       - 完全二叉树的叶子结点只能出现在最深层以及倒数第二层（抽象理解）；
       - 对于任何一个结点，其左分支的最深层次必然大于或等于其右分支的最深层次（<u>因为对于任意结点，左分支可以独立存在，而右分支不可能独立存在</u>）。

  - **性质3**：对于任何一颗二叉树，如果其终端结点(度为0)数为$n_0$，度为2的结点数为$n_2$，则有关系：$n_0=n_2+1$。
    $$
    \begin{align}
    &一颗树的总结点数=度为0+度为1+度为2：\\ 
    &\Rightarrow n=n_0+n_1+n_2 \tag{1}\\ 
    &统计树中总的分支数量有多少，对于每个结点，都仅统计其父节点对其的分支，则除了根结点外，每个结点都有一条分支：\\
    &\Rightarrow B=n-1 (B为分支的总数) \tag{2}\\
    &计算树的分支数量，还可以计算每个结点对其子结点的分支数，即：\\
    &\Rightarrow B = n_1 + 2n_2 \tag{3}\\
    &结合(1)(2)(3)可得：\\
    &\Rightarrow n = n_0 + n_1 + n_2 = n_1 + 2n_2 +1 \Rightarrow n_0 = n_2 +1 \tag{4}
    \end{align}
    $$

  - **性质4**：具有n个结点的<u>完全二叉树</u>的深度为$\downharpoonright  \log_{2}n \downharpoonleft +1$。（不大于$log_{2}n$的最大整数+1）
    $$
    \begin{align}
    &假设所求的层数为k，那么其对应的满二叉树的结点数应该为2^{k}-1，完全二叉树的结点数必然是小于等于其对应的满二叉树的结点数：\\
    & \Rightarrow n \leq 2^{k}-1 \rightarrow  n < 2^{k}\tag{1}\\ 
    &既然其层数为k，则其在第k层至少都包含一个结点，即其结点数必然大于深度k-1的满二叉树的结点数：\\
    &2^{k-1} -1 < n \rightarrow  2^{k-1} \leq n\tag{2}\\
    & \Rightarrow 2^{k-1} \leq n < 2^{k} \rightarrow k-1 \leq  \log_{2}n<k \tag{3}
    \end{align}
    $$

  - **性质5**：如果对结点数为n的完全二叉树按照自上而下，从左到右编号，则结点的编号之间存在以下关系：

    1. 对于根结点之外的任意一个结点若其编号为$i$，则其父节点必然为不大于$\dfrac{i}{2}$的最大整数；
    2. 设某结点的编号为$i$，若$2i>n$，则该节点为叶子结点，否则其左分支结点的编号为$2i$；
    3. 设某结点的编号为$i$，若$2i+1>n$，则该节点必然无右分支(<u>左分支情况未知</u>)，否则其右分支结点的编号为$2i+1$；
    
    理解：**二叉树中父结点为为$i$，则其左右结点必然为$2i$和$2i+1$。**完全二叉树判断是否为叶子结点只需要判断其左分支结点是否存在即可。

- 二叉树的存储：

  - **顺序存储结构**：前面提到的二叉树中的结点可以按照从上到下，从左到右依次编号，编号的过程也就相当于给二叉树建立了一个线性/顺序的索引号，因此，二叉树的顺序存储只需要按照编号依次存储即可。也正是由于顺序存储结构需要与编号依次对应，如果二叉树中包含过多的空结点(左结点或右结点缺失)，则会浪费掉大量的存储空间。对于**完全二叉树**，这种方案或许会为其的遍历带来便捷，但是对于其他的更多的二叉树而言，就只会带来内存的浪费；
  - **链式存储结构**：相比之下，链式存储结构会更加适合二叉树。只需要关注相邻两个结点之间的关系，而淡化了与其他结点之间的关系，也正好符合链式存储结构的特点。依据每个结点中的指针域的数量，二叉树的链式存储结构可以有两种：**二叉链表**和**三叉链表**，顾名思义，二叉链表就是每个结点的指针域中只包含其左子树和右子树的指针域，不包含父级地址的指针域，三叉链表就是全都包含。

- 大根堆与小根堆：

  - 大根堆：对于完全二叉树中的任意一个非叶子结点，其父结点比左右两个分支结点都大，则这样的**完全二叉数**称为大根堆；
  - 小根堆：同上，父节点比左右分支都小的**完全二叉树**为小根堆；
  - 用数学表达为：在一个完全二叉树$T$中，对于任意$0 <= i <= (n-1)/2$的结点：
    - 满足$T[i] >= T[2i+1] \quad \&\& \quad T[i] >= T[2i+2]$，则该完全二叉树为大根堆；
    - 满足$T[i] <= T[2i+1] \quad \&\& \quad T[i] <= T[2i+2]$，则该完全二叉树为小根堆。
  - 大根堆的根结点元素是堆中最大的值，小根堆的根结点元素是堆中最小的值。

- 二叉树的遍历：二叉树是由多个结点构成的，那么二叉树的遍历其实也就是对每个结点的遍历，也就是对根节点，左子树，以及右子树的遍历。可以约定对每个结点的左右子树的遍历顺序为从左到右，那么按照根结点在遍历过程中的次序，可以分为：**先序遍历**，**中序遍历**以及**后序遍历**。

  - 递归的遍历方式：由于每个结点从结构上来看其实都是一致的，所有最容易实现的遍历方案就是采用递归的方法，写好对一个结点的遍历方式，按照先序，中序，或者后序的方案来，在函数内部实现递归即可；
  - 非递归的遍历方式：如果不采用递归，那就需要使用循环来实现：
    1. 从根结点出发；
    2. 如果当前结点不为空，则先将当前结点数据(<u>此时应该是根结点</u>)存入栈中，并赋值左子树的结点地址；
    3. 如果当前为空，则说明该根结点不存在左子树，从栈中取出根结点的地址信息，访问其中的数据，然后赋值右子树的结点地址；
    4. 循环2和3操作，直到堆栈中为空，跳出循环，遍历完毕；

- 线索二叉树：对于一个二叉链表存储的二叉树而言，如果其结点数为n，则必然存在n+1个空的指针域(<u>结合性质3可得证</u>)，线索二叉树就是将这些空的指针域全部利用起来。二叉树的遍历过程，实际上是对一个非线性结构的线性化过程，在此过程中对于除了第一个结点和最后一个结点之后的所有结点，都会出现一个逻辑运算过程中的直接前驱和直接后继，空指针域恰好可以用来保存前驱和后继地址。为此，在线索二叉树的每个结点中，会包含4个指针域：

  - lchild：左子树指针域，如果该节点有左子树，则保存左子树地址，如果没有则保存其在遍历过程中的前驱结点地址；
  - ltag：lchild指针域的标志位，用于标志lchild中保存的是左子树地址还是前驱地址，0->左子树，1->前驱；
  - rchild：右子树或者后继(同上)；
  - rtag：同ltag；

  

