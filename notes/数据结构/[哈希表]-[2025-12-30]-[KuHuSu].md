#### 哈希表原理

在数组中，按照数组的索引位置找数据，该操作的时间复杂度为o(1)，只要直到了索引，直接就能获取到该位置上的数据。那么设置一个函数，该函数能将数据转化为一个整数，创建一个数组用来保存数据，函数计算之后的值作为索引，保存数据。那么当用户想获取数据时，只需要使用同样的函数，将数据转化为索引号，就能直接拿到对应的数据，该操作的时间。

基于以上原理创建的数据结构即为哈希表。转化所使用的函数为哈希函数，常用的哈希函数有除留余数法：用数组的长度来对数据取模即可。

创建哈希表过程中不可避免会出现一个问题——哈希冲突。两个数据使用同一个哈希函数转为之后的索引号一致，是不可避免的。解决哈希冲突的方案主要有两种：**线性探测法**以及**链式哈希表**

**线性探测法**：哈希后的位置有数据，按顺序存放到下一个位置；

**链式哈希表**：每个位置不再保存单独的数据，而是一个链表；



#### 大数据查重

- **哈希表方法**：因为哈希的查找速度是O(1)复杂度，用哈希表能更快的查找数据是否存在于表中，能判断数据是否存在，而且可以统计出现多少次，但是缺点就是**空间占用较多，以空间换时间**。
- **位图算法**：将数据本身作为字节中的位次，比如使用一个4字节的空间来存储，其中第20位用来表征数字20是否存在，存在为1，不存在为0。位图算法能相比哈希表能极值压缩空间，但是其空间会存在浪费。位图算法要求所开辟用来保存保存位是否存在的空间大小必须覆盖所有数据中值最大的那项。**如果数据本身很少，但是最大值很大，就会造成很多位空间的浪费**。位图算法只能判断在不在，不能给出有多少。
- **布隆过滤器**：结合哈希表的查询速度和位图算法的空间优势。使用一个位图数组+K个哈希函数。存入的值首先会经过多个哈希函数计算得到多个位置信息，将位图数组中对应的多个位置全部置1。即：经过布隆过滤器的key值，其对应的K个位置的值必然为1。反之：如果经过经过K个哈希计算后的位置，不全部为1，则key对应而当数据必然不在库中，**布隆过滤器说不在的必然不在**。由于哈希冲突的存在，以及不同哈希函数处理不同key值，得出的哈希结果有可能一致，这就导致某个 key算出来的位置信息可能被其他key的另外一个哈希函数置1，从而产生误判，**布隆过滤器说在的不一定在**。

布隆过滤器对于不存在的判断是百分百正确的，但是对于存在的判断是会存在误判的，虽然误判的概率较低。但是其速度快，空间小，在一些特定的应用场景非常有效。

- 网址过滤：浏览器设置的若干网址黑名单，不允许用户访问。当用户输入一个网址后，可以先经过布隆过滤器，如果判断不在，那必然是不在黑名单的，可以允许用户正常访问；但是如果判断为存在于黑名单中，由于可能存在误判，所以会给出一个危险网站提示，让用户给用户自己选择的权利。即用布隆过滤器管理黑名单。
- ip过滤：服务器的ip黑名单或者白名单机制，同上原理；
- **redis缓存**：服务器架构中一般会设置一个缓存层：前端 - 业务层 - 缓存层 - 数据库层。其中数据库层的数据保存在磁盘上，其IO效率有限，而缓存层则将数据保存在内存中，访问速度快，但是空间远小于磁盘。服务器一般逻辑应该为先尝试从缓存中获取数据，如果 没有再去磁盘数据库中获取数据。redis就是一个内存数据库，为键值数据库，底层实现了一个布隆过滤器。当前端想访问某项数据的时候，先映射出其对应的redis中的key值，再通过布隆过滤器，如果判断为不在，就直接去磁盘中寻找。布隆过滤器开销极小速度极快，简单判断如果不在，就可以免去从redis中寻找数据的过程，减少时间开销。如果判断在，再去redis中寻找，这个过程引入的额外时间消耗几乎可以忽略不计。

