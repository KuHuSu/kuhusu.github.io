[TOC]

### C++的对象和多态

#### struct对象

struct对象可以定义数据类型，如果没有显式的定义构造函数和析构函数，编译器在编译的时候会自动添加一个默认的构造函数和析构函数。

- 构造函数：分配内存，初始化内存空间；(**实际操作就是给结构中的变量赋初始值**)
- 析构函数：释放掉结构中对象占据的内存资源；(可以显式声明一下，具体释放由编译器完成)

1. **struct的构造函数**具备以下特点：

- 构造函数必须与struct对象同名；
- 没有返回值；
- 构造函数可以有多个，以适应多种情况的对象声明；

```c++
struct MyStruct {
    int a;
    double b;

    // 构造函数1，输入的两项分别对应a和b
    MyStruct(int x, double y) : a(x), b(y) {
        std::cout << "Constructor called_____1" << std::endl;
    }

    // 构造函数2，两项都是int类型，则可以在构造函数中转换类型，再赋值初始化
    MyStruct(int x, int y) : a(x), b(static_cast<double>(y)) {
        std::cout << "Constructor called_____2" << std::endl;
    }

    // 构造函数3，同上，输入类型不对，转化类型并初始化
    MyStruct(int x, char y) : a(x), b(static_cast<double>(y)) {
        std::cout << "Constructor called_____3" << std::endl;
    }

    // 析构函数
    ~MyStruct() {
        std::cout << "Destructor called" << std::endl;
    }
};

int main() {
    MyStruct obj1(10, 3.14);  // 调用构造函数1
    MyStruct obj2(10, 20);  // 调用构造函数2
    MyStruct obj3(10, 'a');  // 调用构造函数3    
    std::cout << obj3.b << std::endl;
    return 0;  // 自动调用析构函数
}
```

```powershell
Constructor called_____1
Constructor called_____2
Constructor called_____3
97 //这里的97就是'a'的ASCII码
Destructor called
Destructor called
Destructor called
```

- 类似于`MyStruct(int x, double y) : a(x), b(y) {}`这种的构造函数，称为成员初始化列表构造，冒号后边按照顺序对struct中的变量直接赋值。**优点是开销较小**。

- 另外一种更加直观的构造函数形如：

  ```c++
  MyStruct(int x, double y){
      a=x;
      b=y;
  }
  ```

  优点是可以再函数体内部对输入的参数进行一些复杂操作之后再赋值，**灵活性较高，但是会引入额外的赋值开销**。

2.**struct的析构函数**必须名字为~加上struct名，由编译器完成内存析构，不需要显式的调用。

3.**delete/default**，如果某个类不想写构造和析构函数的实体，可以直接再类内部使用:

```c++
Mystruct() = default;
~Mystruct() = delete;
```

即可直接使用系统默认的构造函数和析构函数。

4.**拷贝构造函数**，如果目前已经存在了 一个类的对象，我希望新建一个对象，该对象使用目前已经存在的对象来赋值。

```c++
 MyStruct(const MyStruct& o): a(o.a),b(o.b){  
 	std::cout << "Constructor called_____4" << std::endl;
 }

MyStruct obj4 = obj3; //可以使用obj3直接给obj4赋值，称为拷贝构造函数
```

这里的输入参数是类的对象，再后续的初始化列表赋值中按照次序依次将对象中的变量赋值给类的变量。

#### 移动语义与完美转发

移动语义是为了避免不必要的拷贝，完美转发是在参数传递的过程中，保持参数值的左值和右值属性不变。

打个比方：

假设现在A(<font color='red'>指向对象的指针</font>)有一栋房子(<font color="red">类的对象</font>)，房子里边有许多的家具(<font color='red'>对象的属性</font>)。B(<font color='blue'>另外一个指针</font>)也想有一懂跟A一摸一样的房子(<font color='orange'>类的拷贝构造</font>)。如果使用拷贝方案，那么拷贝流程如下：

- B先找一个地方(<font color='blue'>B对象的内存地址</font>)建造一个跟A一模一样的房子(<font color='blue'>类的对象</font>)；
- B按照A的家具一比一购置(<font color='blue'>对象的属性</font>)，并放到房子中对应的位置；
- 此时B得到了一个跟A的房子完全一样的房子，同时A的房子依然存在；

如果A和B两人都需要这栋房子，那么这样的操作是合理的。但是如果A房子存在的目的仅仅是为了给B的房子做一个模板，在之后将不再使用，那么这样大规模的复制家具将会造成非常冗余的拷贝资源开销。对此，还有另外一种方案：

- A直接将房子的钥匙🔑给B；(**对象本身没有发生变化，只是这个对象的资源所有权发生了转移**)
- A将钥匙给出后，自己则没有房子了；而B则在瞬间得到了房子，实现了房子的资产转移；

换种说法：

- 拷贝过程中，原对象中的**数据是作为一个左值**，赋值完成后，原对象中的数据依然占据内存空间。

- 移动相当于原对象中的**数据被转换为了一个右值**，在完成赋值后，~~原对象中的数据就不存在了~~。

(<font color='green'>还是有点乱七八糟的，先这么写着，后面理解了再改</font>)

为了达到直接移动而非复制的目的，可以使用`std::move`来告诉编译器，这个变量需要将值取出来转化为右值，实现移动而非拷贝；

#### 面向对象编程

struct是C语言中的关键字，C++中引入是为了兼容C语言。C++作为一门面向对象的语言，有一个更加完善的关键字class。在C++中，struct和class两者的用法非常类似：

- 相同点：都可以包含成员变量、成员函数、构造函数、析构函数；
- 不同点：struct中的成员默认外部都可以访问(<font color='blue'>默认public权限</font>)，而class中的成员默认外部无法访问(<font color='blue'>默认private权限</font>)，需要使用关键字public表明；

##### **封装**

如果我有一个struct类，其中包含多个成员变量，可以对其中的成员变量进行get和set操作。但是我又希望能对这个修改过程进行管控，只能在某些地方被修改和被获取。那我可以隐藏掉结构体，转而使用几个函数实现对结构体的操作，将这几个函数暴露给外部，那么外部就只能通过这几个函数实现对struct的修改，至于我的struct中的结构长啥样，外部在使用函数的时候，是不知道的：

```c++
struct MyObjectHandle {}; //我定义了一个结构体
int MyObjectGetData(MyObjectHandle* handle);  //获取结构体中的数据
void MyObjectSetData(MyObjectHandle* handle, int data);  //修改结构体中的数据
void MyObjectFun(MyObjectHandle* handle);  //对结构体中的函数实现一些操作
```

为了实现struct中的这种功能，class可以使用权限管理来完成封装过程：

- **public**：该class中使用public表明以下的成员**可以在外部被访问**；
- **private**：该class中使用private表明以下的成员**仅在class中可以被访问**，通常是一些内部使用的函数以及成员变量；
- **protected**：该class中使用protected表明的成员**可以在类内部以及派生类中被访问**，外部无法访问；
- class中如果没有显式的指出访问权限，则默认都为private权限。

```c++
class MyClass{
public://外部可以访问的成员
    int getInt(){return a;};//private中的成员变量在类内部可以自由访问
    char getChar(){return b;};
    std::string getString(){return c;};

private:  //由private表明的成员外部均不可访问
    int a=1;
    char b='a';
    std::string c="hello world!";
    
protected:
    int d=9;
};
```

##### **继承**

创建类一般是从什么也没有开始创建，包括类中的各种成员变量和成员函数。但是类的创建也可以站在已有的基础上创建，这种创建方法称为类的继承，类的继承创建方法语法如下：

```c++
class 新类名称: 类的继承方法 基类名称{};
```

- 基类：新的类是在这个类的基础上创建的；
- 新的类：在某个现有类的基础上，创建的一个类，也叫**派生类**；
- 类的继承方法：
  - :star:public：该继承方法会继承基类中的public和protected成员，**在派生类中均不改变其权限**；(大部分均使用public)
  - protected：同上，也会继承基类中的public和protected成员，区别在于**在派生类中都会变为protected**；
  - private：派生类会继承基类的所有成员，但是继承过去后**全都变成private**；

```c++
class NewClass:public MyClass{...}
```

那么可以理解一个点：继承过去后，可以做哪些操作？

- 增加成员：派生类可以在基类的基础上，新增一些成员变量或者成员函数；
- 修改成员：修改掉基类中某些成员函数的逻辑，函数的入参不能改变，只改变函数体中的逻辑，称为**函数重写(override)**；

```c++
class MyClass{ //基类
public: //对外开放的函数接口
    static int getInt(MyClass& obj){return obj.a;};
    const char getChar(){return b;};
    std::string getString(){return c;};
    std::string getName(){return "hello world";};

private: //仅供函数内部使用的成员
    int a=1;
    char b='a';
    std::string c="hello world!";

protected:  //不对外开放，但是派生类可以访问的成员
    int d=9;
};

class NewClass:public MyClass{  //派生类NewClass继承于MyClass
public:
    std::string getName(){  //在其开放接口中，实现对基类中getName函数的重写
        std::cout << MyClass::getName() <<std::endl;//同时如果想引用基类中的函数，可以直接将基类视作命名空间
        return "KHS";
    }
};

int main() {
    NewClass ny;
    std::cout << ny.getChar() <<std::endl;//派生类将继承基类中的对外成员变量，所以可以直接访问
    std::cout << ny.getName() <<std::endl;//派生类中实现对基类函数的重写，派生类中也可以调用基类中的函数
}
```

```powershell
a
hello world
KHS
```

~~**dynamic_cast暂时没理解啥意思**~~



##### **派生类的存储**

如果某个类是某个基类的派生类，那么其对象的存储空间中，首先会满足基类的连续存储，然后才会在基类的基础上，新增派生类中的程序员：

```powershell
+-------------------+
| Base部分          |
|                   |
| baseData          |
| baseFunction      |
+-------------------+
| Derived部分       |
|                   |
| derivedData       |
| derivedFunction   |
+-------------------+
```

<u>如果派生类将基类中的一些成员重写了，那么在基类对应的存储区中，存放的成员就会改为派生类中的成员</u>。同时，由于派生类中基类的存储是保证处于连续空间的，那么**创建一个派生类的对象，也可以使用基类的指针来链接**。这也是C++实现运行时多态的底层逻辑。反过来，**派生类指针则不能指向基类对象**。



##### **多态**

多态，通俗来说就是，针对一个函数，调用它的时候，他的实现的原理可以有多种。这里的**”态“实际指的就是函数的具体实现细节**。

根据系统执行多态的时序，可以分为**编译时多态**以及**运行时多态**：

- 编译时多态：指的是某一个函数，其接收的参数可以有多种形式，分别对应不同的函数实现。以上的这一事实，在程序编译的时候就知道了。这种一般就是在类中对同名函数实现多个**重载(OverLoad)**，明确的指出，某个函数有多个版本，系统在编译的时候就能发现函数的多个版本；
- 运行时多态：假设基类中有一个函数`func`，编译器在编译的时候只会发现该函数只有一个版本，是不具备多态的。但是这个基类被其他两个派生类继承了，在派生类中均实现了对基类中`func`函数的**重写(Override)**。而我在使用这个基类的时候，我使用基类的指针，指向的是不同派生类的对象。从上文中可以得出，派生类中如果将基类中的某个函数重写了，那么在存储空间中会替换成派生类中的数据。因此尽管我创建了两个基类指针，但是由于两个基类指针指向的是不同的派生类对象，在调用同一个函数的时候，实际上运行的是派生类中的函数重写：

```c++
class Animal {
public:
    virtual void speak() {
        cout << "Animal speaks" << endl;
    }
};
class Dog : public Animal {
public:
    void speak() override {
        cout << "Dog barks" << endl;
    }
};
class Cat : public Animal {
public:
    void speak() override {
        cout << "Cat meows" << endl;
    }
};
```

```c++
Animal* animal1 = new Dog();
Animal* animal2 = new Cat();
animal1->speak();
animal2->speak();
```

```c++
Dog barks
Cat meows
```

比如上面这个程序，基类Animal中的speak函数，在派生类Dog和Cat中被重写了，后续运行具体程序时，使用指针指向不同对象，进而实现同一函数的不同实现。以上这个过程，是在函数运行时，顺着指针方向链接才实现的，称为运行时多态。需要注意的一点，<u>在基类中，需要实现多态的函数必须使用关键字`virtual`修饰，或称为**虚函数**</u>。

需要注意：

- 就算没有`virtual`修饰的函数，在派生类中也可以被重写，但是当使用基类指针或者引用调用函数时，无法定位到派生类中；
- 如果在基类中使用`virtual`修饰了某个函数，而在派生类中实现了多态，则**建议将基类的析构函数也设为虚函数**，这样在通过指针析构时能正确的析构派生类对象，而不是基类对象；

```c++
class Animal {
    public:
        virtual void speak() {
            std::cout << "Animal speaks" << std::endl;
        }

        ~Animal(){  //基类的析构函数没有被修饰为虚函数，则不具备多态
            std::cout << "destory Animal" << std::endl;
        }
};
class Dog : public Animal {
    public:
        void speak() override {
            std::cout << "Dog barks" << std::endl;
        }

        ~Dog(){
            std::cout << "destory Dog" << std::endl;
        }
};
```

```c++
int main() {
    Animal* animal1 = new Dog();
    animal1->speak();
    delete animal1;
    return 0;
}
```

```c++
Dog barks
destory Animal  //animal1指针指向的实际上是Dog对象，析构时也应该析构Dog对象。但是由于基类中的析构并没有支持多态，所以这里出现了错误的析构
```

上面的示例中，就出现了没有使用`virtual`修饰的基类函数被重写，可以看到执行时并没有实现多态，实际的派生类对象也没有被正确析构。因此一般支持多态的基类的析构函数也要写为虚函数：

```c++
virtual ~Animal(){
    std::cout << "destory Animal" << std::endl;
}
```

这种情况下再次调用指针的析构函数时，就会正确的将派生类对象析构：

```c++
Dog barks
destory Dog  //派生类对象被正确析构
destory Animal
```

<font color='red'>**这里需要注意:**</font>当继承类中重写了基类中的虚函数，通过指针调用继承类中的指定函数的时候，会运行两个函数，顺序依次为继承类->基类。(原因暂时空着)

##### **抽象类**

实现多态时，需要使用到`virtual`关键字修饰，被称为虚函数。在基类中，虚函数可以包含定义，也可以仅仅做个声明，具体的定义在派生类中。**仅包含声明的虚函数称为纯虚函数**。如果基类中<font color='red'>**包含**</font>纯虚函数，则该基类被称为虚类。(<u>有点类似Java中的Interface</u>)

- 基类中的纯虚函数需要使用`=0`来显式的表明为纯虚函数；
- 派生类中对虚函数的重写需要使用`override`关键字标注；
- **虚类不可被实例化**，即使在虚类中实现了对纯虚函数的重载；
- 继承虚类的派生类中**必须实现对其中所有<font color='red'>纯虚函数</font>的定义**，否则不可被实例化；
- 虚类中没有被显式标注为纯虚函数的函数，哪怕没有具体定义，在派生类中也可以不被重写；

```c++
class Animal {
    public:
        virtual void func()=0;  //使用=0显式表明为纯虚函数
};
class Dog : public Animal {
    public:
        void func() override{  //在派生类中必须实现对基类中所有纯虚函数的重写，并使用关键字override标注
            std::cout << 1 << std::endl;
        }
};

int main() {
    Animal an;  //无法编译，因为虚类不能被实例化
    Animal* animal1 = new Dog();
    return 0;
}
```



##### **类的作用域**

基类与派生类的作用域呈现嵌套关系，基类中的可以被继承的成员，其作用包含了派生类的作用域。派生类中成员的作用域仅限于派生类内部以及子派生域。在派生域中，如果想要直接引用基类中的函数：

```c++
class Base {
public:
    void Func() {}
};
class Derive : public Base {
public:
    void Func() {};
    void Foo() {
        Func(); // 调用 Derive 的实现
        Base::Func(); // 显式引用基类作用域中的Func函数
    };
};
```



##### **类中的static成员**

一个类中的成员 如果被static修饰，那么这个成员具有以下特征：

- 该成员不再属于类的对象，而属于类本身，可以<u>假设类的定义时有一个空间，而类的对象需要在实例化时才能有空间</u>。也就是说类在实例化对象时，并不会包含静态成员，**静态成员对于类对象的大小没有任何影响**；

```c++
class MyClass{
public:
    static const int b=1;

    int a=1;
    int c=2;
    int d=3;
};

int main() {
    MyClass my;
    std::cout << sizeof(my) << std::endl; //输出12，仅计算了a,c,d三个int类型的空间，不包含静态成员b
}
```

- 按照逻辑来说，静态成员不再属于类对象，但是依旧可以使用类的对象访问(<font color='red'>**不推荐，不符合语法逻辑**</font>)；
- 静态成员属于类本身，因此可以直接使用类的命名空间访问(<font color='green'>**推荐**</font>);
- 类中被定义为静态函数的函数，无法访问类中的非静态变量，<u>非静态变量属于某个具体的对象，不在其类的空间中</u>；
- 类中的静态变量要么使用`const`限制为常量，要么只能声明，在类的外部定义；

```c++
class MyClass{
public:
    static int getInt(){return test;};  //静态函数，属于类本身，只能引用类中的静态变量
    static const int test=9; //类中的静态常量
    static int b; //类中的静态，非常量只能在类中完成声明，定义必须在类的外部
    int a=8; //类中的非静态变量，属于类的某个具体对象，静态函数不可引用
};

int main() {
    MyClass my;
    int Myclass::b=7; //类中静态非常量需要在类外部定义
    std::cout << my.getInt() << std::endl;
    std::cout << my.test << std::endl; //属于类本身的成员，也可以使用类的对象访问，但是不推荐
    std::cout << MyClass::getInt() << std::endl;
    std::cout << MyClass::test << std::endl; //推荐使用类的空间直接访问静态成员
}
```



#### 函数模板

​	如果有多个函数同名，但是其传入的参数不一样，这样的多个函数叫做函数的**重载**。在函数重载中，如果仅仅是函数的入参类型不一样，函数体内部的逻辑完全一致，那么可以将这些重载函数写成一个**函数模板**，相当于将入参的数据类型也作为函数参数的一部分这样的一组函数，叫做**函数模板**。函数模板需要使用关键字`template`标注：

```c++
template<typename T> //使用关键字template标注模板函数，在模板函数中定义了用于表示参数类型的符号T
T func(T a,T b){     //在函数实现中，T代表了广泛的一种数据类型，可以是C++原始类型，也可以是自定义类型
    T c = a+b;
    return c;
}

struct mystruct{  //自定义数据类型
    int a,b;
    mystruct(int data1,int data2):a(data1),b(data2){};
    mystruct operator+(const mystruct& other) const{  //在数据类型中自定义了加法的逻辑
        return mystruct(a*2+other.b*3,0);
    }
};
    
int main() {
    int a=2,b=3;
    std::cout << func(a,b) <<std::endl;  //int类型，返回5

    double c=12.5,d=1.25;
    std::cout << func(c,d) <<std::endl;  //double类型，返回13.25

    std::string e="hello ",f="world!";
    std::cout << func(e,f) <<std::endl;  //字符串类型，返回“hello world!”

    mystruct m1(1,3),m2(2,5);
    mystruct m3 = func(m1,m2);           //自定义类型，重载了加法运算
    std::cout << m3.a <<std::endl;       //返回17
}
```

函数模板在编译时由于不确定函数类型，所有编译过程并不会生成相应大汇编代码。而是在函数具体的运行过程中，接收到指定的数据类型以后，才会尝试实例化代码。因此**可以将模板函数放在头文件中**。

函数模板在程序中使用时，编译器会根据具体传入的参数自动推断模板类型，也可以指定类型：

```c++
double c=12.5,d=1.25;
std::cout << func<double>(c,d) <<std::endl;
```



##### 函数模板特化

假如，我是说假如。有一组重载函数，其中大部分都是仅有入参的数据类型不一样，函数实现逻辑完全一致。但是偏偏有一个逆子，他的入参也是仅类型不同，但是函数内部的实现逻辑跟其他的都不一样。对于这样的逆子，可以单独拎出来，在原有的函数模板的基础上，做一个特化，特化其函数的实现逻辑，这种操作就叫做**函数模板特化**：

```c++
// 通用函数模板
template <typename T>
bool compare(const T& a, const T& b) {
    return a < b;
}

// 特化版本，针对int类型
template <>
bool compare<int>(const int& a, const int& b) {
    return a > b; // 特化版本的比较逻辑
}

int main() {
    int a = 5, b = 3;
    cout << "Comparing ints: " << compare(a, b) << endl; // 调用特化版本

    double c = 5.5, d = 3.3;
    cout << "Comparing doubles: " << compare(c, d) << endl; // 调用通用版本

    return 0;
}
```

特化的函数模板由于已经确定了其数据类型，因此在编译时就会将该函数实例化。编译器在编译某段程序时，会首先查找特化的模板函数，如果能匹配上，则 不用再调用函数模板实例化函数；如果匹配不上则会使用函数模板实例化具体数据类型对于的函数。

那假如，逆子不止一个，而是一群呢？那就**可以对模板函数进行重载**：

```c++
template<typename T>  //通用模板函数，入参a和b的数据类型保持一致
T func(T a,T b){
    T c = a+b;
    return c;
};

template<>
mystruct func<mystruct>(mystruct a,mystruct b){  //针对自定义类型，在通用基础上做特化
    int m1 = a.a*b.b;
    int m2 = a.b*b.a;
    mystruct m3(m1,m2);
    return m3;
}

template<typename U>  //另外有一部分函数中，需要限定入参a的数据类型为int，则重载一个函数模板
U func(int a,U b){
    int i=0;
    while(i<a){
        b+=b;
        i++;
    }
    return b;
};
```

##### 函数模板折叠引用(没看懂)

大概就是说假如函数模板的类型是一个T&&，实际在函数实例化的过程中，如果具体传入的参数是左值，则模板类型自动会折叠为左值e，传入的是右值，则模板类型不变。

std::forward用于参数在转发的过程中，保证参数的左值和右值类型不变；传入是左值，转发过程中保持左值，传入是右值，转发过程中保持右值；

std::move传入的值无论左值还是右值，转发过程中都会被转变为右值。



#### 类模板

类似于函数模板，如果类在定义过程中，其中有一些参数可以是多种类型的，也可以使用`template`标注为模板类。区别于函数模板，类模板在实例化时，**必须要显式的指出数据类型**。

