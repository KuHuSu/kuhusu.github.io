[TOC]

### C++变量与数据

------

#### C++内置数据类型

- void：定义指针以及函数返回值；

- std::nullptr_t：空指针；

- float：浮点数32位；

- double：浮点数64位；

- int：整数类型，按照整数类型的长度以及符号，还能细分：

  - signed：有符号
  - unsigned：无符号
  - short：16位
  - long：32位
  - long long：64位

  直接使用int，默认为有符号整数。**在64位系统以及32位系统中，默认使用4字节存储**，并且至少需要能表示$-(2^{15}-1)~+(2^{15}-1)$范围内的数据，即至少需要表示有符号16位的数字。5种对int的修饰符，可以随意组合，也可以随意变换位置顺序：

  ```c++
  int long unsigned long 与 unsigned long long int 是完全等价的，表示无符号64位整数。
  ```

#### 结构体struct

```c++
struct Mystruct_1 {
    int i; #4
    char ch; #4
    float f; #4
};
struct Mystruct_2 {
    int i; #4
    char ch1; #4
    double d1; #8
   	char ch2; #8
    double d2; #8
};
```

上述结构体Mystruct_1中，int和float本身就占据了4个字节的内存，而char本身只会占据1个字节，但是在struct中分配的内存一般会给到4个字节。原因有以下两点：

- 结构体中每个对象分配到的内存必须是该对象数据类型所需内存的整数倍；
- 结构体总内存时其中最大内存的整数倍；

具体计算时，可以假设第一个数据地址为0x00：

```c++
int i:从地址0开始，本身所需4字节倍数，分配4字节；0x00-0x03
char ch1:从地址4开始，本身占据1个字节，使用1个字节；0x04 -> 补充3字节 0x04-0x07
double d1:按道理应该从地址5开始，但是double本身占据8字节，而0x05不是8的倍数，因此需要从0x08开始;0x08-0x0f
char ch2:从地址0x10开始，本身仅占据1个字节：0x10 -> 补充7字节 0x10-0x07
double d2:从地址0x18开始，本身需要8字节，地址从0x18开始，符合条件：0x18-0x1f
所以总占据的内存空间应该为0x00-0x1f总计32个字节的空间。
```

从上面的计算看出，数据占据的内存，并不是死板的全部按照最大数据类型计算，而是<u>根据其前后两个数据的内存占用空间动态调整的</u>；同时，也能够看出，在定义结构的时候，如果将结构中的数据按照从大到小的顺序排列，能够有效减少内存占用的空间。

```c++
struct Mystruct_1 {
    double d1; //8
    double d2; //8
    int i; //4
    char ch1; //1
   	char ch2; //1
};
struct Mystruct_2 {
    int i; //4
    char ch1; //4
    double d1; //8
   	char ch2; //8
    double d2; //8
};

int main(){
    std::cout << "Size of Mystruct_1 is :" <<sizeof(Mystruct_1) << std::endl;
    std::cout << "Size of Mystruct_2 is :" << sizeof(Mystruct_2) << std::endl;
}
```

```
Size of Mystruct_1 is :24
Size of Mystruct_2 is :32
```

实际上对于这里的Mystruct_1，即使将后面的两个char去掉，占据的空间仍然是24字节，因为需要<u>补齐到最大内存的整数倍</u>。

#### 联合union

union类似于struct，但是**union中的所有的成员变量共享同一块内存**，在某一时刻，union中仅有一个变量的值是正确的，其他变量的值均为随机数，因此也可以推出<u>union所占据的内存空间为其成员变量的最大内存值</u>：

```C++
union myunion {
    int i; //4
    char ch1; //4
    double d2; //8
};

int main(){
    myunion u;
    u.i=56;
    std::cout << " u.i is :" << u.i << std::endl;
    std::cout << " u.ch1 is :" << u.ch1<< std::endl;
    std::cout << " u.d2 is :" << u.d2 << std::endl;

    u.d2=0.25254;
    std::cout << " u.i is :" << u.i << std::endl;
    std::cout << " u.ch1 is :" << u.ch1<< std::endl;
    std::cout << " u.d2 is :" << u.d2 << std::endl;
}
```

```c++
 u.i is :56 //仅赋值了i，则只有该值为正确的
 u.ch1 is :8
 u.d2 is :2.76677e-322
     
 u.i is :-2009357500
 u.ch1 is :D
 u.d2 is :0.25254 //仅赋值了d2，则只有该值为正确的
```

#### 枚举enum

枚举类型用于定义一组离散的常量，相当于定义了一组离散的宏，在枚举类型中包含多个变量，**每个变量都对应一个int类型的常量**，如果没有显式的指定对应常量值，则会从0开始依次给变量赋值。如果显式赋值为非int类型，则会转化为对应的ASCII码。

枚举类型的使用不同于struct和union：

1. 第一种用法类似于命名空间，使用双冒号索引，比如myunion::TEST_ENUM；
2. 第二种用法则将枚举类视作一个数据类型，初始化变量时直接赋值其中的某一个量，比如myunion en = TEST_ENUM；

```c++
enum MyColor {
    COLOR_RED = 5,
    COLOR_BLUE = 9,
    COLOR_BLACK= 'C',
};

int main(){
    std::cout << " Color is :" << MyColor::COLOR_BLACK << std::endl;

    MyColor en = COLOR_RED;
    std::cout << " Color is :" << en << std::endl;
}
```

```c++
 Color is :67 //字符"C"对应的ASCII码
 Color is :5
```

#### 变量声明与定义

- 变量的声明：变量的声明过程只是告诉编译器，现在有一个名字为xxx的变量，编译器需要检查一下是不是合法即可，**不会给变量分配内存**；
- 变量的定义：变量的定义会将变量名跟某一块确定的内存空间绑定在一起，即**变量的定义会为给变量分配一块内存空间**；
- 原生的数据类型没有使用extern关键字时，相当于定义，其初始值就是分配的地址上原本的那个值。

```c++
int main(){
    unsigned long int a;
    int b[10];
    extern unsigned int val7;

    std::cout << " Address of a is :" << &a << " Value of a is :" << a << std::endl;
    std::cout << " Address of b is :" << &b << " Value of b is :" << b[0] << std::endl;
    std::cout << " Address of val7 is :" << &val7 << " Value of val7 is :" << val7 << std::endl;
}
```

```c++
Address of a is :0x61fe4c Value of a is :0 
Address of b is :0x61fe20 Value of b is :8 //定义，但是没有初始化，内存块上本身就有这个值
[Done] exited with code=1 in 0.882 seconds //声明未定义，不分配内存，无法获取地址，会报错
```

#### 指针与引用

- 指针：指针也是一个变量，其中保存的是某个变量的地址。所以，**指针就是地址**。

对于指针变量，有两个运算符需要知道：&和*

1. &：取地址符，是一个自右向左操作符，置于给定变量的左侧，意味着取出该变量的存储地址，所以**该操作符右侧是一个变量**；
2. *：取数据，给定一个地址，取出该地址上存储的数据，所以**该变量的右侧只能是一个地址**；

```c++
int main(){
    double a=0.0001;    //定义一个变量a，赋值为0.0001，存储地址由os分配
    std::cout << " Value of a is :" << a << std::endl; //直接使用a即可获取其值

    double* p = &a; //定义一个指针量p，使用&获取a的地址，给p初始化
    * p = 0.0005; //使用*获取指针p指向的内存中的数据，并赋值修改
    std::cout << " Address of a is :" << p <<std::endl;
    std::cout << " Value of a is :" << *p << std::endl;
    std::cout << " Value of a is :" << a << std::endl;
}
```

```c++
 Value of a is :0.0001
 Address of a is :0x61fe40 //指针就是地址，直接输出指针其实就是一个地址量
 Value of a is :0.0005
 Value of a is :0.0005 //通过指针修改内存中的数据后，与内存绑定的变量的值也会发生改变，即修改*p等价于修改a
```

可以总结：

- int* p 和*p这两个均包含\*，但是含义不一样，前者\*代表p是个指针变量，int代表指针指向的内存中保存的数据为int类型。而后者代表获取指针p指向地址中保存的数据。所以：

  ```c++
  int *p=&a; //正确，指针的定义
  int* p=&a; //正确，定义指针时*的位置没有要求
  *p=a; //正确，*表示取地址中的值，值与值相互赋值
  *p=&a; //错误，*取地址中保存的数据值，&a取地址，地址和值不能赋值
  &*p=&a=p; //正确，从右到左依次看，*p表示的是一个值，&后接值表示的是取出值的地址。&a表示地址，指针P也是地址，三个地址可以相互传递
  *&p=a=*p; //正确，&p先获取地址，再使用*获取地址中保存的值，所以*&p表示的是值，a和*p同样表示的是值。
  ```

#### 常量指针const

使用关键字const修饰的变量为常量，修饰为常量的量，常量再程序运行过程中不能修改。如果结合指针使用，就会有两种位置：

1. 指针本身是常量；
2. 指针指向的地址空间中的数据是常量；

第一种，如果指针本身是常量，则const应该修饰指针，而不是指向地址的数据类型，称为**顶层常量**所以应该形如：

```c++
int* const ptr;
```

第二种，如果希望指向地址的数据是常量，则应该修饰在表示数据类型的修饰符上，称为**底层常量**：

```c++
const int* ptr;
int const* ptr; //const与int的顺序可变换，跟unsigned，long等修饰符一样
```

#### 左值和右值

首先看几个赋值语句：

```c++
a=3;   //a是左值，代表确定的内存地址；3是右值，仅代表值本身
b=a+3; //b是左值，a是右值，但是a+3这个整体是一个左值
```

在上面的两个赋值语句中，赋值号左边的值称为左值，可以看出，左值是有确定的地址和内存空间的；而赋值号右边的值，称为右值，右值是用来给确定地址的变量赋值的，其生命周期较短，仅在赋值这个过程中出现，使用的仅仅是他的值，是无法获取其地址空间的。概括如下：

- 左值：可以出现在赋值号左右两边(**左边情况居多**)的值，**引用左值，引用的是值对应的地址**；
- 右值：**只能**出现在赋值号右边的值，**引用右值，引用的仅仅是值本身，不能引用其地址**；

左值和右值的引用：C++11中出现了专门用于左值的引用，和专门用于右值的引用

```c++
void fun(int& val) { std::cout << "int&" << std::endl; }
void fun(int&& val) { std::cout << "int&&" << std::endl; }
```

比如上面的两个重构函数，第一个使用`int&`，表示这里的入参只能是左值，也就是有确定内存地址的值；而第二个函数使用`int&&`，表示右值引用，只能传入确定的值，而非变量或内存：

```c++
int a = 0;
fun(a); // int&  a是左值，对应第一个函数
fun(2); // int&& 3是右值，对应第二个函数
```

#### 类型转换

1. 隐式的类型转换：C++中有一些表达式可能会隐式的将数据的类型转换

   - 条件判断：non-bool -> bool，比如

     ```c++
     int a = 4; //int类型，为非bool类型
     if(a) {...} //if中的a被隐式的转换为了bool类型
     ```

   - 其他，我不能理解。

2. 显式的类型转换：也可以使用一些内置的方法，实现类型的显式转换

   - static_cast：大部分情况均适用。只要不包含底层const，均可以使用static_cast实现类型转换

     ```c++
     int i=2;
     double b = static_cast<double>(i);
     char c = static_cast<double>(i); //模板函数，使用<>指定需要转换的数据类型
     ```

   - const_cast：对于包含底层const的指针，使用const_cast可以去除或增添底层数据的常量属性

     ```c++
     const int* ptr;  //const修饰int，表明指针地址中保存的数据为const属性，为底层const
     char* ptr1 = const_cast<char*>(ptr); //使用const_cast将底层的const int类型转换为char类型，去除了const
     const double* ptr2 = const_cast<const double*>(ptr1);//也可以使用const_cast为底层数据添加上一个const属性
     ```

   - reinterpret_cast：专用于指针的类型转换工具。如果指针的底层数据没有被const修饰，可以直接使用该方法进行类型转换 

     ```c++
     int* ptr;
     char* ptr1 = reinterpret_cast<char*>(ptr);//将指针地址上的数据改为char格式
     ```

### C++表达式和语句

------

#### C++语句

- 简单语句：末尾加上；就代表是一句完整的语句

- 块语句：如果使用大括号{}将多个语句整合起来，就称为一个语句块。常见的函数体就是一个语句块。C++中{}也可以不依附于函数，独立存在，表示变量的作用域：

  ```c++
  int main(){
      {
          int a=5;
          std::cout << a << std::endl; //a在作用域中定义，则在作用域中有效，这里输出5
      }
      std::cout << a << std::endl; //这里的a处于作用域外，无效，未定义
  }
  ```

  如果某个变量是在某个作用域内部定义的，比如上面的a，那么a的值仅在该作用域中有效。使用作用域可以：

  - 提升代码可读性，分块易于理解；
  - 避免因变量名重复而带来的程序歧义；

- 逻辑控制语句：总共四类逻辑控制语句

  - 条件控制语句：if-else，switch；
  - 循环控制语句：for，while；
  - 跳转控制语句：break，continue，goto；
  - 异常处理语句：try

#### 变量的作用域

C++中每个变量都是存在于某个特定的作用域中，超出作用域之外的变量没有意义，总共包含以下几个作用域：

- 全局作用域：程序中包含多个函数，多个类，如果某个函数、类或者变量是在程序中的所有函数和类的外部定义的，则这些量在全局的所有位置均可见，可使用，有效；
- 块作用域：在程序中单独使用{}框起来的语句处于一个块作用域中，该域中的变量仅在块作用域内部生效；
- 函数参数作用域：如果某个变量是以函数参数的形式进入程序，则其仅在函数内部的作用域中生效；
- 命名空间作用域：如果项目较大，难免会存在较多的变量命名冲突，为此可以将多个相同的变量名存放于不同的命名空间中，则不同命名空间中的同一个变量名其作用域也不同；
- 类作用域：如果某变量是在某类中定义，则变量的作用域仅在类的范围内；

```C++
int a= 2; //全局变量
int func(int&& a){
    std::cout << a << std::endl; //这里的a是函数的参数，属于参数作用域，其值由入参赋值
}

namespace nams{int a=3;}; //a为命名空间中的局部变量，仅当使用该命名空间时有效

class num{
public:
    int a=1; //类中的局部变量
};

int main(){
    int a=5; //函数体中定义的局部变量
    {
        int a=6; //块作用域中的局部变量，超出块范围后无效
        std::cout << a << std::endl; //这里输出的是块定义的a
    }
    std::cout << a << std::endl; //main函数中定义的a
    func(4); //将4作为参数值，赋值给参数中的a
    std::cout << ::a << std::endl; //由于局部中存在同名的变量，需要使用::显式得表明引用全局变量
    std::cout << nams::a << std::endl;//命名空间中的a
    num N;
    std::cout << N.a << std::endl; //类中的a
}
```

比如上面的程序中，总共出现了5处对变量a的定义，虽然是相同的变量名，但是由于各自所处的命名空间不一致，对应的变量值也各不相同。也能总结出一个原理：<u>变量的值如果没有显式的表明全局/类/命名空间，则会优先考虑当前所处的局部变量值</u>。即局部变量的优先级要大于全局变量。

#### 命名空间

命名空间是C++中为了避免多个变量名冲突，引入的一种命名机制，变量仅在命名空间内生效，命名空间的创建使用关键词：`namespace`一般有三种命名方式：

```c++
namespace ns-name {declarations}; //常用，一般式
inline namespace ns-name {declarations};//嵌套命名空间，内联命名
namespace {declarations}; //匿名命名空间，在链接的时候有用
```

定义示例如下：

```c++
namespace ns1 {
    int a = 3;
    inline namespace ns2 {
        int b = 4;
    };
};
```

- 在使用命名空间中的变量时，使用`::`链接命名空间与变量即可，类似于python中引用类中的参数使用`.`链接一样；
- 如果在某个作用域中需要大量使用到某个命名空间中的变量，可以在作用域中使用`using`关键字将其中的变量全部引入即可：

```c++
int main(){
    using namespace ns1; //在main函数内，可以直接使用ns1中的变量
    std::cout << a << std::endl; //3
    {
        using namespace ns1::ns2; //在块作用域中，可以直接使用ns1::ns2中的变量
        std::cout << b << std::endl; //4
    }    
}
```

- 匿名命名空间：使用`namespace`可以命名匿名的命名空间，其作用与常规的命名空间有所不同，其功能更接近于静态变量。凡是在匿名命名空间中定义的变量，在编译器编译时，只会在一个编译单元中生效。即就是从某个cpp文件出发，处理include，宏，预处理指令的整个过程中涉及到的范围内有效。

#### 符号查找与类型检查

c++程序在编译前，会首先检查程序中出现的符号，检查这个符号是什么，是代表变量还是代表一个函数；

如果代表的是变量，变量的值是多少，优先从当前作用域开始查找，没有则到外一层的作用域中查找，直到找到为止；

如果代表的是函数，那么函数的本地在哪里，也需要逐层寻找；

确定了程序中的符号以后，就会开始类型检查，如果变量以及函数的类型出错 则会编译失败；

#### 关键字extern/static

如果某个C++项目涉及到多个文件之间的交互，我希望在有一个变量在其中的某一个文件中定义后，其他文件都可以共享定义的这个函数值；也存在一些变量，其值仅存在于当前文件中，其他文件中不可访问该变量；

- extern：这个关键字用于声明一个多个文件共享的，全局变量：

  ```c++
  //utils.cpp文件中
  int a=3;  //没有任何修饰，默认是全局变量
  void func(){
      std::cout << "this" << std::endl;
  };
  namespace ns {  //具名的命名空间默认问全局变量
      int val = 5; //如果内部变量没有被static修饰，则默认具有外部可链接性
  }
  extern const int n = 50; //单独使用const结合extern关键表明为全局常量
  ```

  ```c++
  //main.cpp中
  namespace ns {
      extern int val; //使用extern声明该变量，即可直接使用在utils中定义赋值的变量
  };
  
  extern void func();
  
  int main(){
      extern int a;
      extern const int n; //声明变量时，需要注意，声明过程中的修饰符必须跟源文件中的保持一致
      std::cout << a << std::endl; 
      std::cout << n << std::endl;
      std::cout << ns::val << std::endl; 
      func();
  }
  ```

  ```powershell
  g++ .\main.cpp .\utils.cpp -o test
  .\test
  3
  50
  5
  this
  ```

  将具有共享变量的多个文件联合编译，可以看到使用 extern关键字修饰的变量，其值在不同文件之间实现了值传递。

- static：用于声明仅存在于当前文件中的局部变量：

  ```c++
  //utils.cpp中
  static int a = 8; //static修饰的局部变量
  const int b = 10; //const修饰的常量，默认为静态
  namespace {
      int c = 50;
  };  //匿名命名空间中的变量仅在当前的编译单元中有效
  ```

#### 变量存储期

C++中的变量存储期决定了变量存储的位置以及存在的时间，C++总共包含四种存储期：

- 静态存储期：其中的变量在程序运行的整个期间都有效，在程序结束之后释放掉内存空间
  - 生命周期：从程序启动到程序结束；
  - 作用域：可以是全局变量也可以是局部变量；
  - 存储位置：全局存储区；
- **自动存储期**：自动存储区的变脸通常只在其所在的作用域内生效。块作用域，函数作用域中的变量通常都保存于此
  - 生命周期：作用域开始到作用域结束；
  - 作用域：所在的局部的作用域；
  - 存储位置：**一般保存在栈上**；
- 线程存储期：在多线程的项目中，线程所独立使用的变量具备的存储特征
  - 生命周期：线程开始到线程结束；
  - 作用域：通常是线程中有效的局部变量；
  - 存储位置：线程独立分配到的线程存储区
- **动态存储期**：动态存储区中的内存由程序员手动分配以及手动释放，变量的生命周期完全由程序员决定
  - 生命周期：程序员显式分配到显式释放；
  - 作用域：**通常通过指针访问**；
  - 存储位置：**一般保存在堆上**。

#### 符号的链接属性

根据一个C++程序中，某个符号是否能被其他程序访问到，可以将符号分为三种链接属性：

- 外部链接：程序中一些符号完成定义赋值后，外部的程序使用**extern**关键字声明符号即可使用：
  - 由extern关键字修饰的变量或者函数；
  - 程序中位于全局作用域中的变量或者函数，默认外部可链接；
  - 由namespace定义的具名命名空间中，**除去const或者static修饰的变量以外**，默认外部可链接；
- 内部链接：在程序中定义和赋值以后，只能在当前文件中使用，外部程序无法访问：
  - 在全局作用域中由static修饰的变量，仅能在当前程序内部访问；
  - **仅**由const修饰的常量，默认只能在程序内部链接(**同时具备extern const则外部可链接**)；
  - 匿名命名空间中的变量，只能在当前的编译单元内链接；
- 无链接：一般位于程序的某个局部作用域中的变量(块作用域/函数作用域)，是不具备链接属性的。