#### 第一章 基础知识

```matlab
1、计算机由微处理器（CPU）、程序存储器（ROM）、数据存储器（RAM）、总线（DB+CB+AB）以及输入输出设备（I/O口）构成。
	其中微处理器是微型计算机的核心部件，包含运算器（ALU）、控制器（CU）以及寄存器组（R）构成的；
	具备完整运算功能和控制功能的计算机就叫做微型机；
	微机系统是以微型机为核心，加上硬件设备（电源、辅助电路以及外设）和软件（系统软件和应用软件）构成的系统；
	将构成微型计算机的所有部件集成到一个芯片上构成单片机。
	
2、ALU单元是算术逻辑单元（analysis logic unit），其主要功能是进行数据的处理与加工，包括数据的加减乘除等算术运算以及与或非等逻
	辑运算。

3、PC中当前内容表示下一个要执行的指令的地址。当程序顺序进行时，PC保存程序的第一条指令的地址，而后每次读取下一条指令都会将指令的地
	址寄存到PC中，PC总是指向下一个指令的地址。

4、标志寄存器F由称为程序状态字，其包含7个状态字，分别是进位标志CY，半进位标志AC，自定义标志F0，工作寄存区选区RS1和RS0，溢出标志
	OV以及累加器的奇偶校验为P。分别对应着单片机工作时产的一些特征标志，以及需要定义的一些标志。

5、堆栈是在RAM区划分出的一个特殊区域，用来暂存程序运行过程中的一些状态或者数据，堆栈的的选取一般选在地址30H到7FH之间。堆栈按照先
	入后出的工作方式，堆栈指针总是指向堆顶。采用关键字PUSH将数据压入堆栈，采用POP将数据取出。

6、存储器由存储矩阵、地址译码器、数据缓冲器、以及读写控制构成。存储矩阵包含多个8位寄存单元，按照线性地址排列；地址译码器是将输入的
	地址编号转化成能够锁定对应存储位置的输出信号，以此来确定数据的位置。数据缓冲器的作用就是对输出输出数据进行一个缓冲作用。读写控
	制是控制存储器的读写状态。
	
7、指令由两个部分构成，分别是操作码和操作数。

8、指令的执行过程：按当前PC中的地址取指令地址，完成后PC+1；将得到的指令地址进行译码，得到对应的操作码；取操作数地址；操作数地址译
	码；取得操作数；执行操作。（取指-译码-取操作数地址-译码-取操作数-执指）
	
9、PC当前内容为指令ADD A的操作码地址，将PC中的地址送到地址寄存器，确保寄存器接收到以后，PC指向PC+1的位置（也就是操作数地址）；
	接着对地址寄存器中的地址译码，得到对应的操作码“0010 0100”；PC端送出此时操作码的地址，送到地址寄存器，PC+1；操作数地址译
	码；按地址取得操作数；执行指令。
	
10、内部总线是单片机内部连接各个部件之间的公共信息通道；外部总线是当单片机需要连接外部拓展时，用来连接和控制各个拓展的公共信息通
	道。
	其中地址总线AB是CPU读取外部数据是送出的地址，是单向三态的，只能由CPU送往CPU外部；
	数据总线DB是双向三态的，可以由CPU将数据送到外部，也可由外部将数据送给CPU；
	控制总线CB是单向三态的，但是其方向不固定，某些控制线只能由CPU送往外部，某些控制线又只能由外部送往CPU。
	
11、最大的寻址范围是2的16次方，即64K寻址空间。
```

#### 第二章 硬件结构

```matlab
1、51单片机的主要功能特点包括：
	片内4KROM，128BRAM；片外64K地址和数据存储器寻址空间；（4/128/64）
	8位CPU；5个中断源；4个8位并行I/O口；2个16位定时/计数器；2个优先级；（85422）
	特殊功能寄存器；全双工串行口；布尔处理器；片内震荡以及时钟电路。

2、总共23个特殊功能寄存器，其中PC物理上独立，其余22个都在SFR存储区。有3个属于8032和8052系列。总结：8051系列包含20个特殊功能寄
	存器，包含5个双字节寄存器，加上PC也是双字节寄存器，所以总共占据26个字节。
	
3、PC属于特殊功能寄存器，其功能是保存下一条指令的地址。

4、DPTR由两个部分组成：DPH和DPL，分别保存DPTR的高八位字符和低八位字符，DPTR是外部地址寄存器，高八位保存外部地址高八位，低八位
	保存外部地址低八位，寻址空间64K。
	
5、堆栈可以设置在30H到7FH内的位置，采用关键词PUSH和POP实现压入和取出，遵循先入后出原则，堆栈永远指向堆顶，复位指向07H。

6、PSW叫做程序状态字，主要用于反应CPU在运行过程中产生的一些标志位，以及控制工作寄存器选区。常用的有CY、AV、OV、RS1、RS0、P。可
	以位寻址。
	
7、51单片机的I/O口线有32条，P0口作为地址低八位与数据总线的共用口，P2作为地址高八位总线，总计16条地址总线，8条数据总线，P3口作为
	控制总线，但控制总线还包括EA/PSEN/RESTART/ALE总计12条控制总线。
	
8、片内无ROM时，需要先通过EA选通外部程序存储器，同时在ALE和PSEN控制的配合下才能使用数据总线和地址总线。ALE高电平时，将地址送到
	地址总线上，ALE下降沿将地址锁存到外部存储器，PSEN为低电平时，P0口上才会出现数据，单片机读取该数据进行进一步操作。
	
9、ALE高电平时地址总线上出现外部存储器的地址，在ALE下降沿时将地址锁存到外部存储器进行外部地址访问。

10、检查晶振是否正常工作，ALE是否有脉冲输出。

11、准双向口是指该输入输出口在使用前需要先向其内部寄存器输入1，才能保证正常工作。P0内部不存在上拉电阻属于真双向口，P1、P2、P3内
	部都有上拉电阻，都属于准双向口，在使用前需要先向其输入1。
	
12、内部4KROM与外部64KROM，其中外部64KROM的前4K地址与内部ROM地址重合；内部128BRAM以及外部64KRAM，前128B地址与片内RAM地址
	重合。
	
13、不存在重叠。采用不同的指令来读取不同的选区，MOVC读外部程序存储器，配合PSEN；MOVX读外部数据存储器，配合RD和WR。

14、虽然位置重叠，但是在使用过程中分别采用直接寻址和间接寻址的方式，来区分两个选区：80H~FFH采用间接寻址，SFR区域采用直接寻址。

15、RAM的80H~FFH区域内以及SFR区域内，两者共用同一内存地址，都是在80H~FFH之间。

16、分为3个区域，分别是：
	工作寄存器区（00H~1FH），该区域分为4个选区，每个选区对应8个工作寄存器R0~7，选区的选区由程序状态字PSW中的SR1和RS0决定；
	位寻址区（20H~2FH），包含16个字节的地址空间，总共有16×8=128个可位寻址的空间，编码为00H~FFH；
	数据缓冲区（30H~7FH），该部分可用作堆栈，只能字节寻址。
	
17、不会冲突，虽然地址重复了，但是在具体使用中位寻址和字节寻址有不同的操作码，可以对应到不同的区域。

18、不能，特殊功能寄存区都只能直接寻址访问，对52系列来说，间接寻址访问会访问到与SFR具有共用地址的片内RAM区。

19、时钟周期是原始晶振的震荡频率，机器周期是时钟周期的12分频，指令周期是一个指令完成所需要的机器周期，51中指令周期为1~3个机器周
	期。
	
20、P1口8个可用，P0、P2用作地址总线，P0作数据总线、P3作控制总线。

21、复位后，SP指向07H，P0~P3全为高电平，除此之外 其余全部都是复位为0。复位后使用的是第一组寄存器，地址为00H~07H，可以通过改变
	PSW中的RS1和RS0对选区进行更改。
	
22、复位后地址为00H~07H，压入堆栈或者将数据转移到另外一个备用寄存器中。
```

#### 第三章 指令系统

```matlab
1、7种：立即数寻址；直接地址寻址；寄存器寻址；寄存区间接寻址；基址寄存器加变址寄存器间接寻址（51独有）；相对寻址；位寻址。

2、5类：数据传输类；算数运算类；逻辑运算类；控制跳转类；布尔处理类。（伪指令不算）

3、8个：ORG;DB;DW;DS;DATA;EQU;BIT;END。

4、(70H)=B7H;(B)=20H;(R1)=60H;(R0)=70H;（MOV P1, #0FFH；是因为P1是准双向口，需要先输入1才能作为输入输出口使用）

5、将存放在R1和R0中的双字节数据×16，即左移4位。将高位移到R2中。

6、周期：[2+（2+250×4+2）×10+1+2]×2 = 20090μs。将P1.0口作为一个方波信号发生器，周期为20090μs。

7、将30H~39H这10个立即数送到外部数据存储器的2000H~2009H的位置中。

8、将外部数据存储器2000H~204FH位置上的数据存入堆栈中，最后堆栈指向2FH+50H=7FH。

9、相当于将堆栈中的10个数据整体往前移动一位，最后SP指向3FH-10H=2FH；

10、将30H位置上的数据高四位存放到34H中，低四位存放到33H中。	

11、12、

13、（1）01101011+10000001 = 11101100=ECH；CY=0,AC=0,OV=0异或0=0；
	（2）01101011+10001100 = 11110111=F7H；CY=0,AC=1,OV=0;
	（3）01101011+01110010+0=11011101=DDH；CY=0,AC=0,OV=1异或1=0；
	（4）01101011+01111001+1=11100100=E4H；CY=0,AC=1,OC=1异或1=0；
	（5）01101011-11111001-1=
	
14、（1）两个双字节数据分别存放在R0R1，和R2R3中，将两个数相加，低位存放在30H中，高位存放在31H中，进位存放在32H中。
	（2）两个双字节数存放在R5R4和R32R2中，相减的高位放在R1中，低位放在R0中。
	（3）R1R2中保存一个双字节数，R1中为低8位，R0中保存一个8位数据。将双字节数与8位数据相乘，由高到低存放在32H,31H,30H中。
	
15、好多好多种。

16、长跳转指令的跳转的空间为64KB寻址空间中的任意位置，绝对跳转AJMP的跳转空间为当前区中的不同位置转移，SJMP是相对转移，根据给定
	的偏移量从当前位置出发转移到偏移的位置，其跳转范围为当前位置的-128~+127空间内。
	
17、目标位置=当前位置+指令长度+偏移量。

18、累加器与立即数，寄存器与立即数，间接寻址寄存器与立即数，累加器与直接地址。CJNE是条件转移指令，当两个数据不相等时跳转。

19、（1）00010010:起始第2区第2页···00010110：目标第2区第6页，不超范围。AJMP 1620H 
	（2）00100111：起始第4区第7页···00100101：目标第4区第5页，不超范围。AJMP 2530H
	（3）00011110：起始第3区第6页···00011010：目标第3区第2页，不超范围。AJMP 1A00H
	（4）00010010：起始第2区第2页···00010110：目标第2区第6页，不超范围。ACALL 1620H
	（5）00100111：起始第4区第7页···00100101：目标第4区第5页，不超范围。ACALL 2530H
	（6）00100111：起始第4区第7页···00101010：目标第5区第2页，超出范围。
	（7）2340H＜FFFFH，不超范围，rel=2340H-2330H-2H=3EH；SJMP 3EH
	（8）不超范围，rel=2866H-2800H+2H=68H=01101000；SJMP E8H
	（9）超出范围，rel=27FEH-2730H+2H=D0H>7FH。超出偏转范围。
	
20、A中数据为0FFH时，跳转到LABEL1，当A中的数据为00H时，跳转到LABEL2。

21、由位ALU，位累加器CY，数据存储器和I/O口构成。主要功能是位运算，主要是逻辑运算、传送和转移控制。

22、位处理有单独的指令集，仅针对可以位寻址的寄存器。

23、	F=/U+/V+W+/X
	ORG 0000H
	U BIT P1.0
	V BIT P1.1
	W BIT P1.2
	X BIT P1.3
	F1 BIT ACC.0
	
	MOV P1,#0FH
	MOV C,U
	ANL C,V
	CPL C
	MOV F1,C
	MOV C,W
	ORL C,/X
	ORL C,F1
	MOV F,C
	END

24、(1)
	MOV C,P1.3
	ANL C,ACC.2
	MOV ACC.0,C
	MOV C,B.5
	ANL C,P1.1
	ORL C,ACC.0
	MOV PSW.5,C
	(2)
	MOV C,P1.5
    ANL C,B.4
    MOV ACC.0,C
    MOV C,ACC.7
    ANL C,P1.0
    ORL C,ACC.0
    CPL C
    MOV PSW.5,C 
	
```

#### 第四章 汇编程序

```matlab
1、
DELY2M: MOV R7,#100
DLY0:   MOV R6,#8
		NOP
DLY1:	DJNZ R6,DLY1
		DJNZ R7,DLY0
		RET
		(100×（2+2+8×2）=100×20=2000)
			
DELY1S: MOV R7,#50
DLY0:	MOV R6,#100  
DLY1:	MOV R5,#98
		NOP
DLY2:	DJNZ R5,DLY2
		DJNZ R6,DLY1
		DJNZ R7,DLY0
		RET

2、
	ORG 2000H
	MOV A,20H
	MOV B,#64H
	DIV A B
	MOV 30H,A
	MOV A,B
	MOV B,#0AH
	DIV A B
	SWAP A
	ADD A,B(ORL A,B)
	MOV 31H,A
	SJMP $
	END

3、
	ORG 1000H
	MOV A,#0FH
	ANL A,30H(取低四位)
	MOV B,A
	MOV A,#0F0H
	ANL A,30H(取高四位)
	MUL AB
	MOV 31H,A
	END
	
4、	ORG 1000H
	MOV A,20H
	MOV C,ACC.7
	JNC FUCK
	CLR C
	MOV A,21H
	SUBB A,#1
	CPL A
	MOV 21H,A
	MOV A,20H
	SUBB A,#0
	CPL A
	MOV 20H,A	
FUCK:NOP
	SJMP $
	END
	
5、ORG 1000H
	MOV R7,#8
	MOV R2,#0
	MOV R0,#30H
	CLR A
K1: ADD A,@R0
	MOV R1,A
	CLR A
	ADDC A,R2
	MOV R2,A
	MOV A,R1
	INC R0
	CLR C
	DJNZ R7,K1
	MOV R6,#3
K2: MOV A,R2
	RLC A
	MOV R2,A
	MOV A,R1
	RLC A
	MOV R1,A
	CLR C
	DJNZ R6,K2
	MOV A,R1
	MOV 38H,A
	SJMP $
	END
	
6、ORG 1000H
	MOV DPTR,#2000H
	MOV R0,#30H
	MOV R7,#50H
K1: MOVX A,@DPTR
	MOV @R0,A
	INC DPL
	INC R0
	DJNZ R7,K1
	SJMP $
	END
	
7、
BLOCK DATA 10H
LEN   DATA 11H
MINI  DATA 12H
	ORG 1000H
	MOV R0,#BLOCK
    MOV R7,LEN
    DEC R7
    MOV A,@R0
    MOV B,A
K1: CLR C
	INC R0
    MOV A,@R0
    SUBB A,B
    JNC K2
    MOV B,A
K2: DJNZ R7,K1
	MOV A,B
	MOV MINI,A
	SJMP $
	END
    
8、
BLOCK DATA 10H
LEN   DATA 11H
PSUM  DATA 12H
MSUM  DATA 13H
	ORG 1000H
	MOV R0,#BLOCK
    MOV R7,LEN
    MOV A,#0
    MOV PSUM,A
    MOV MSUM,A
LOOP:MOV A,@R0
	JB ACC.7,ADDM
ADDP:ADD A,PSUM
	MOV PUSM,A
	SJMP NEXT
ADDM:ADD A,MSUM
	MOV MSUM,A
NEXT:INC R0
	DJNZ R7,LOOP
	SJMP $
	END
	
9、
BLOCK DATA 10H
LEN   DATA 60H
ORG 1000H
START:
	MOV R7,LEN
	MOV R0,#BLOCK
	MOV A,R0
	INC A
	MOV R1,A;(R0中为前一个数的地址，R1中为后一个数的地址)
	DEC R7	;(对比次数为长度减1)
	CLR F0  ;(标志位，用来标志是否翻转过)
LOOP:
	MOV A,@R0
	MOV R2,A
	MOV A,@R1
	MOV A,R3
	ACALL K1 ;(子程序，完成翻转，小数在R2大数在R3)
	MOV A,R2
	MOV @R0,A
	MOV A,R3
	MOV @R1,A
	INC R0
	INC R1
	DJNZ R7,LOOP
	JB  F0,START ;(F0是1则说明翻转过，从头再来一次)
	SJMP HAL
K1: MOV A,R3
	SUBB A,R2
	JNC K2   ;(A=R3<R2不跳转，完成两者翻转后再跳转)
    XCH A,R2
    MOV R3,A ;(R2<R3)
    STEB F0  ;(FLAG=1)
K2: NOP 
	RET
HAL:SJMP $
	END
	
书上的外部排序，注意要把DPL单独拎出来加减：	
ORG 1000H
BLOCK DATA 2200H
LEN   DATA 51H
TEM   DATA 50H
	MOV DPTR,#BLOCK
	MOV P2,DPH
	MOV R7,LEN
	DEC R7
LOOP0:CLR F0
	MOV R0,DPL
	MOV R1,DPL
	INC R1
	MOV A,R7
	MOV R6,A
LOOP1:MOVX A,@R0
	MOV TEM,A
	MOVX,A,@R1
	CJNE A,TEM,NEXT
	SJMP NOCHA
NEXT:JC NOCHA
	SETB F0
	MOVX @R0,A
	XCH A,TEM
	MOV @R1,A
NOCHA:INC R0
	INC R1
	DJNZ R6,LOOP1
	JNB F0,HAL
	DJNZ R7,LOOP0
HAL:SJMP $
	END

10、(R2R3)累计16位，最大数据FFFFH为65535
ORG 1000H
	MOV R0,#60H
	MOV R4,#0
	MOV R5,#0
	MOV R6,#0
    MOV R7,#16
W:	MOV A,R3
	RLC A
	MOV R3,A
	MOV A,R2,
	RLC A
	MOV R2,A  ;(CY=最高位)
	MOV A,R6
	RLC A
	MOV R6,A  ;(R6中保存从双字节R2R3中左移出去的数据)
	CLR C
	SUBB A,#64H ;(A-100)
	CPL C
	MOV A,
	
	TAINANL

11、ORG 1000H
	MOV RO,#60H
	MOV R1,#80H
	MOV DPTR,#ASCTAB
	MOV R7,#16	
K1:	MOV A,@R0
	ANL A,#F0H
	SWAP A
	MOVC A,@A+DPTR
	MOV @R1,A
	INC R1
	MOV A,@R0
	ANL A,#0FH
	MOVC A,@A+DPTR
	MOV @R1,A
	INC R1
	INC R0
	DJNZ R7,K1
	RET	
ASCTAB:
	DB 30H,31H,32H,33H
	DB 34H,35H,36H,37H	
	DB 38H,39H,41H,42H
	DB 43H,44H,45H,46H
	END
	
12、正奇数，最高位0，最低位1；正偶数，最高位0，最低位0；
	负奇数，最高位1，最低位1；负偶数，最高位1，最低位0；
	ORG 1000H
	ONE DATA 20H
	TWO DATA 21H
	FUNC DATA 22H
	MOV A,ONE
	JZ ZERO        ;(A=0则直接跳转到ZERO程序)
	JB ACC.7,MFUNC ;(高位为1，负数，则跳转负数处理程序)
	JB ACC.0,SUM   ;(低位为1则跳转正奇数处理程序，同负偶数处理程序)
	ANL A,TWO
	MOV FUNC,A
	SJMP HEL
MFUNC:
	JB ACC.0,F1    ;(低位为1则跳转负奇数处理程序)
SUM:ADD A,TWO
	MOV FUNC,A
	SJMP HEL
F1: ORL A,TWO
	MOV FUNC,A
	SJMP HEL
ZERO:MOV FUNC,A
HEL:SJMP $
	END
	
13、
	ORG 1000H
	VAR DATA 30H
	FUNC DATA 31H
	MOV A,VAR
	JZ ZERO
	JB ACC.7,M1
	MOV A,#1
	SJMP ZERO
M1: MOV A,#81H (-1)	
ZERO:MOV FUNC,A
	SJMP $
	END
	
14、
	ORG 1000H
	VAR DATA 30H
	FUNC DATA 31H
	CLR C
	MOV A,VAR
	SUBB A,#20
	JNC ONE
	MOV A,VAR
	SUBB A,#10
	JC TWO
EQ: MOV A,#0
	SJMP HEL
ONE:JZ EQ     ;(A中数据为0，则跳转，说明A=20,返回相等处理程序)
	MOV A,#1
	SJMP HEL
TWO:MOV A,#81H
	SJMP HEL
HEL:MOV FUNC,A
	SJMP $
	END

15、假设转换后的目的分支均处于第1个选区内，即选区首地址为#0800H,
	2K空间分为16个分支，每个分支占7位二进制。
	ORG 1000H
	MOV DPTR,#DBL
	MOV A,R3
	JMP @A+DPTR
	RET
DBL: AJMP  ADDR1
	 AJMP  ADDR2
	 ......
	 AJMP  ADDR15
	 AJMP  ADDR16
	 END
	 
16、同15，DBL改为任意64KB空间的位置。
	ORG 1000H
	MOV DPTR,#DBL
	MOV A,R3
	JMP @A+DPTR
	RET
DBL: LJMP  ADDR1
	 LJMP  ADDR2
	 ......
	 LJMP  ADDR15
	 LJMP  ADDR16
	 END


17、
LOAD4:
	MOV A,@R0
	MOV R4,A
	INC R0
	MOV A,@R0
	MOV R5,A
	INC R0
	MOV A,@R0
	MOV R6,A
	INC R0
	MOV A,@R0
	MOV R7,A
	INC R0
	RET
	
18、
SQR:ANL A,#7FH ;(高位置0，取绝对值)
	ADD A,#1   ;(中间只有一个字节的间隔)
	MOVC A,@A+PC
	RET
DBL:DB 0 ,1 ,4 , 9
	DB 16,25,36,49
	DB 64,81,100,121
	DB 169,196,0,0
	
19、 
NRRC:MOV A,@R0
	RRC A
	MOV @R0,A
	INC R0
	CLR C
	DJNZ R7,NRRC	
	RET

20、
MUL10:
	MOV R1,#30H;(结果低位地址)
	MOV B,#10
	MOV A,@R0
	MUL AB
	ADD A,@R1
	MOV @R1,A
	INC R1
	MOV A,B
	ADDC A,@R1
	INC R0
	CLR C
	DJNZ R7,MUL10
	RET
	
 21、
 MUL4:
 	MOV R7,#3
 	MOV A,R2
 	MOV B,A
LOOP:MOV A,@R0
 	MUL AB
 	ADD A,@R1
 	MOV @R1,A
 	INC R1
 	MOV A,B
 	ADDC A,@R1
 	INC R0
 	CLR C
 	DJNZ R7,LOOP
 	RET
 	
 22、移位相减法，32
 DIV4: 
 	MOV R7,#32
 	MOV R1,#0
 	MOV R3,#0
 	MOV R4,#0
 	MOV R5,#0
L3:	CLR C
	MOV R1,#4
 	MOV R0,#30H
L1: MOV A,@R0
 	RLC A
 	MOV @R0,A
 	INC R0
 	DJNZ R1,L1
 	MOV A,R2
 	RLC A
 	MOV R2,A
 	CLR C    ;(此时R2中保存着从被除数高位移出的数据)
 	MOV A,R6
 	MOV B,A
 	MOV A,R2
 	SUBB A,B ;(A中为高位进位，B中为除数)
 	JNC L2   ;(若高位进位大于或等于除数，借位标志为0，保留相减结果，其他情况不保留)
 	CLR C
 	AJMP L4
L2: SETB C
	MOV R2,A ;(把相减的差作为新的被减数，保存在R2中，继续接收高位进位)
L4:	MOV A,R5
 	RLC A
 	MOV R5,A
 	MOV A,R4
 	RLC A
 	MOV R4,A
 	MOV A,R3
 	RLC A
 	MOV R3,A
 	DJNZ R7,L3;(32位全部移动完之后，R2中最终的数据即为余数，R3R4R5中一步一个数据地移入的数据为商)
 	RET
 
 23、测试就是说，51控制输出某些信号，该芯片处理信号之后，送到Y口，同时，51自己对输出的信号作相同的运算，两者作比较。
 	相当于用51实现该逻辑。
 ORG 1000H
 	AI BIT P1.0
 	BI BIT P1.1
 	CI BIT P1.2
 	DI BIT P1.3
 	EI BIT P1.4
 	FI BIT P1.5
 	GI BIT P1.6
 	HI BIT P1.7
 	YI BIT P3.0
 TEST:
	MOV C,AI
	ANL C,BI
	ANL C,CI
	ANL C,DI
	MOV ACC.7,C
	MOV C,EI
	ANL C,FI
	ANL C,GI
	ANL C,HI
	ORL C,ACC.7;(此时的C中为ABCD+EFGH,相当于/Y)
	ANL C,/YI
	MOV ACC.6,C
	MOV C,ACC.7
	CPL C      ;(此时的C为(ABCD+EFGH)取反，即为Y)
	ANL C,YI
	ORL C,ACC.6
	MOV F0,C   ;(用同或逻辑判断计算结果与送回的YI是否一致，若F0为1，则表示芯片功能正常)
	SJMP $
	END
	
24、6与13相连，则下计数器的高位作为上计数器的时钟，也就说，8位输入从低到高排序为：
	3/4/5/6/11/10/9/8,3为最低位，8为最高位。同时也说明这是一个加法计数器。最高计数M=256。
	可以通过初态计算计数次数，按次数对CP信号进行翻转，翻转到达指定次数后，计时器将定格在00H。
	如果取0FFH为最高计数，则最终定格在0FFH
	ORG 1000H
	CP BIT P3.0
TEST:
	SETB F0   ;(初始状态为1，表示默认功能异常，后续通过检测后复位)
	CLR CP 
	MOV A,P1
	MOV A,B
	MOV A,#0FFH；最高计数理论上是256，但只有8位，取其最高255，计数器最终将定格在0FFH
	SUBB A,B
    MOV R7,A
L1: CPL CP
    DJNZ R7,L1 ;理论上计数完成时，此时的状态将会定格在0FFH，所以只需要对比当前状态与0FFH是否相等即可
   	MOV A,P1
   	CJNE A,#0FFH,OUT
   	CLR F0
OUT:SJMP $     ;(不相等则跳过F0复位指令，F0继续保持1，表明功能异常)
    END   
    
```

#### 第五章 定时计数串行中断

```matlab
1、51系列有2个T1和T0，构成的寄存器包括方式寄存器TMOD，控制寄存器TCON，高8位字节TH1,TH0,低8位字节TL1,TL0。

2、作计时器使用时，芯片上的T0和T1作为计数脉冲输入。由于最高计数频率为1/24分频，所以需要保证外部计数脉冲的高电平与低电平都至少维
	持一个机器周期以上。
	
3、GATE,C/T,M1,M0;GATE,C/T,M1,M0高四位控制T1计数器的门控、计数计数选择、工作方式。低四位控制T0计数器的相同三项功能。

4、TF1,TR1,TF0,TR0。分别表示T1溢出标志，T1启动控制，T0溢出标志，T0启动控制。

5、4种。00方式0，工作在16位计数器或定时器；01方式1，工作在13位定时器或计数器，高8位加上低8位的低5位构成13位；10方式2，可自动重
	加载的8位定时器或计数器，TH作重装载的赋值寄存器，TL作工作寄存器；11方式3，T1不工作，T0作8位计数器或定时器。(原因是T1的中断
	控制被T0占用了，当T1不需要中断控制时，仍然可以使用。)
	
6、51内部的计数器和定时器都是加法计数器，工作方式为每收到一个脉冲信号，计数器加1，一直加到最大的状态时溢出。因此需要的定时时长或者 
	计数次数在相同位数下取决于初始值的大小。51的定时器和计数器是可以编程的，因此需要对其初始化以达到目标效果。初始化的一般步骤
	为：1、对方式状态字赋值；2、对定时器或计数器的初值TH1/0和TL1/0赋值;3、对T1、T0的中断状态赋值，包括中断允许和优先级；4、对
	控制寄存器赋值，主要是TR1/0赋值，开启定时器或计数器。
	
7、方式1：
	ORG 1000H
	MOV TMOD,#10H
	MOV TH1,#0FCH
	MOV TL1,#18H
	SETB EA
	SETB ET1
	SETB TR1
	SJMP $
	ORG 001BH
BRT1:CPL P1.0
	MOV TH1,#0FCH
	MOV TL1,#18H
	RETI
	
	ORG 1000H
	MOV A,#10001000B
	MOV TMOD,#10H
	MOV TH1,#0FEH
	MOV TL1,#0CH
	SETB EA
	SETB ET1
	SETB TR1
	SJMP $
	ORG 001BH
BRT1:
	MOV C,ACC.7
	MOV P1.1,C
	RL A
	MOV TH1,#0FEH
	MOV TL1,#0CH
	RETI

方式0：
	ORG 1000H
	MOV TMOD,#00H
	MOV TH1,#0E0H
	MOV TL1,#18H
	SETB EA
	SETB ET1
	SETB TR1
	SJMP $
	ORG 001BH
BRT1:CPL P1.0
	MOV TH1,#0E0H
	MOV TL1,#18H
	RETI
		
	ORG 1000H
	MOV A,#10001000B
	MOV TMOD,#00H
	MOV TH1,#0F0H
	MOV TL1,#0CH
	SETB EA
	SETB ET1
	SETB TR1
	SJMP $
	ORG 001BH
BRT1:
	MOV C,ACC.7
	MOV P1.1,C
	RL A
	MOV TH1,#0F0H
	MOV TL1,#0CH
	RETI
	
8、最长采用16位方式1定时，最长为65536μs。采用T1作定时器，T0作计数器，T1定时60000μs，T0计数500次（下降沿计数）。
	P1.0口作定时器输出方波口，将P1.0连接到T0口作为T0计数器的输入脉冲即可。最终的1分钟结束有P1.1口输出。
	ORG 1000H
	LJMP START
	ORG 001BH
	SJMP BRT1
	ORG 000BH
	SJMP BRT0
	ORG 2000H
START:
	MOV TMOD,#14H ;T1方式1，作定时器；T0方式0，作计数器；
	MOV TH1,#15H
	MOV TL1,#0A0H
	MOV TH0,#0F0H
	MOV TL0,#0CH
	SETB EA
	SETB ET1
	SETB ET0
	SETB TR1
	SETB TR0
	SJMP $
BRT1:
	MOV TH1,#15H
	MOV TL1,#0A0H
	CPL P1.0
	RETI
BRT0:
	MOV TH0,#0F0H
	MOV TL0,#0CH
	CLR P1.1
	RETI
	
9、根据书上的例子，需要采用门控位来测试，需要将外部中断引脚INT0接到待测方波上。
	MOV TMOD,#09H
	MOV TH0,#0
	MOV TL0,#0
	JB  P3.2,$
	SETB TR0
	JNB P3.2,$
	JB  P3.2,$
	CLR TR0
	此时TH0和TL0中的数据即为数据的正脉冲宽度。
	
10、单工串行口即只能往一个方向传送数据。
	半双工即数据可以实现双向传输，但是在同一时刻，数据只能往一个方向传送。
	全双工即在同一时刻，数据可以往两个方向传送。
	
11、在串行通信中，数据是随机时间连续发送的，系统需要知道何时开始接收字符以及何时字符发送结束，以及区分一个字符与另外一个字符。

12、包含控制寄存器SCON与特殊功能寄存器PCON。SCON主要用于选择串行口的通讯方式，包含4种方式：00方式0作移位寄存器，01方式1作8位串
	行口，波特率可调；10方式1作9位串行口（加上控制位），波特率2档；11作9位串行口，波特率可调。同时还包含串口的允许接收控制REN，
	方式2、3中的第9位数据，以及发送结束/接受结束的标志位即中断请求位。SM2控制是否要收到停止位才申请中断，SM2置1，则无论哪种方式
	(主要是1.2.3)都必须接收到最后一位停止位时，才标志着数据接收结束。置0时，只要数据传输结束，不用验证停止位的信息，就可以发出接
	收结束的信号。PCON的最高位SMOD用于控制波特率是否乘2。
	
13、4种。如上。

14、移位寄存器，方式0，作I/O拓展或者接输入输出设备，由RXD完成输入输出，由TXD同步移位信号。（RST，R在前，通过R完成收发）
	8位串行，方式1，一般用于数据的单项传送，由主机向从机发送数据；
	9位串行，方式2和3，其中方式2的波特率只有两种，方式3的波特率可以自由调整，主要用于多机通讯，需要由多出的一位数据来检验传输过	程的数据准确性。
	
15、方式0。方式0为移位寄存器模式，由RXD端口实现数据的双向传输，由TXD传送同步移位信号。方式0发送的一帧数据包含10位，1位起始位，8
	位数据位以及1为结束位。当数据被传输到串行输出寄存器SBUF中后，数据就会从RXD口传输到外部，TXD传送同步移位信号。当传输结束时，
	中断标志TI置1。数据接收时，首先由由系统软件置位REN，数据开始从RXD端口送入主机，同时将移位信号从TXD端口送入，接收到8位数据之
	后，接受中断标志RI置1。(方式0不需要等停止位才结束，只需要8位数据收齐就结束接收)
	方式1。方式1为8位串行通讯模式。其传输的数据包含10位，1位起始位，8位数据位以及1位结束位。数据发送时，由用户将数据送到串行输出
	寄存器SBUF，数据便会从TXD端口送出，当发送完结束位以后，发送中断标志TI置1。在接收数据时，首先系统软件置位允许接收控制REN，然
	后系统将收到的每位采样16次，取其中的7、8、9三次采样结果中多数的状态作为实际输入。接收数据前先验证起始位，当发现起始位后，数
	据开始接收。如果SM2=1，则需要等到最后一位停止位收到后，并且此时RI=0，同时满足两个条件时，才会置位接收中断；如果SM2=0，则不
	需要等到停止位，数据传送结束并且RI=0就可以直接置位接收中断位。
	
16、中断申请源TCON以及SCON，中断允许寄存器IE，中断优先寄存器IP。TCON中TF1、TF0表示定时器、计数器溢出标志同时也是中断申请标	
	志；IE1和IE0分别为外部中断INT1和INT0的中断请求标志；IT1和IT0控制外部中断INT1和INT0的的触发方式，1表示下降沿触发，0表示
	低电平触发。在SCON中RI和TI分别表示接收和发送中断申请标志。IE中依次包含EA,ET2,ES,ET1,EX1,ET0,EX0，分别表示总中断允许，
	T2中断允许（52系列），串行口中断允许，T1中断允许，外部中断INT1允许，T0中断允许，外部中断INT0允许。IP中依次包含PT2、PS、
	PT1、PX1、PT0、PX0，分别表示T2中断优先（52系列），串行口中断优先，T1中断优先，外部中断INT1优先，T0中断优先，外部中断INT0
	优先。

17、TF1,TF0,IE1,IT1,IE0,IT0如上。

18、TI,RI如上。

19、51系统内有5个优先级。自然优先级从低到高为(T2),ES,T1,X1,T0,X0。通过设置中断优先寄存器IP对优先级进行设置。
	一个正在执行的低级中断服务可以被更高级的中断打断，但不能被同级中断服务打断。
	正在执行的高级中断服务不能被任何中断打断，并且在执行完返回主程序后还需要执行一次指令才能响应新的中断服务。
	
20、相同之处：1、两者在进入时都需要对现场进行保护，即保护下一条指令的地址；
			2、两者在都能实现多级的嵌套使用；
			3、两者都需要跳转到指定的位置执行程序。
    不同之处：1、中断服务是由软硬件联合控制的，需要由硬件完成部分中断的申请，子程序是由软件控制的，不需要硬件参与；
			2、中断服务的进入时机是随机的，由具体中断服务需要的申请时间决定，而子程序的进入时间是由程序事先设计好的；
			3、中断服务与主程序是互不相关的，子程序是完全为主程序服务的；
			4、中断嵌套的层数一般比较少，比如51只能实现最多2层的优先级，子程序的嵌套层数由系统的性能决定，多于中断；
			
21、满足几个条件：1、接收到中断请求；
			   2、当前时间处于某个指令的最后一个机器周期中；
			   3、当前没有执行更高级或同级的中断服务；
			   4、当前的指令不是RETI或访问IE,IP中。（结束访问之后需要再执行一条指令才能响应）
	中断请求受阻时，系统会现将中断挂起，等系统满足中断响应的条件后，再响应中断。
			   
22、系统收到中断请求，查看中断优先级，并置位相应优先级状态触发器，自动复位中断标志，自动保护断点，将对应的中断服务入点送到PC进入中
	断服务，完成中断服务后由RETI指令返回主程序。
	正常状况下，查询中断状态（检查是否符合中断响应条件）消耗1周期，保护断点消耗2周期，总计3周期。
	异常状况视具体情况而定，在除去高级中断的情况下，最多的异常状态为当前为REII(2周期)，出来后第一条指令为3周期合计5周期。
	所以响应时间为3~8个机器周期。
	如果是因为高级中断异常，则响应时间由高级中断的执行时间+中断结束之后的首条指令周期决定。
	
23、两种触发方式，通过改变TCON中的IT1和IT0修改，状态为0表示低电平触发，状态为1表示下降沿边沿触发。对于电平触发方式，需要确保低
	电平能够一直维持直到系统响应中断，并能够在中断返回之前恢复到高电平状态，以防止CPU再次响应中断；对于边沿触发方式，边沿的检测需
	要耗费2个机器周期，为了确保能够负边沿能够顺利被检测到，需要保证负脉冲（脉冲，不是电平）至少维持1个机器周期的时间。
	
24、采用低电平触发方式，通过复位TCON中的ITx标志即可实现，同时，在系统响应之后需要立即对中断请求信号做出置位控制。

25、不能，中断服务程序有特定的存储位置，对应关系为：T2-002BH,SBUF-003H,T1-001BH,INT1-0013H,T0-000BH,INT0-0003H。
	如果要实现将中断放在其他位置，可以在指定的入口中添加无条件转移指令完成，比如在ORG 0013H，后面LJMP 2000H
	
26、将内部中断源中的定时器/计数器T1和T0作为计数器工作，并将初始值设置为溢出值减1，则在收到一个脉冲后，就能触发计数器的中断请求，
	其效果与外部中断请求效果一致。需对内部初始化如下：
	MOV TMOD,#06H(计数器T0工作方式2，自动装载)
	MOV TL0,#0FFH
	MOV THL,#0FFH
	SETB EA
	STEB ET0
	SETB TR0
	
27、将其中的1个优先级最高的连接到INT0，剩下的按照优先级排序，由高到低依次连接P1.6~P1.0，同时将剩余6个中断采用或门连接到INT1。
	这样如果优先级最高的中断在请求中断服务，则优先响应最高优先级中断，其余6个只要有中断请求，INT1都会收到中断申请，在响应INT1的
	中断后，进入到INT1的服务程序，在程序中，按照P1.6到P1.0的顺序查找具体是哪一个中断源在申请中断。INT1的服务程序中需要做如下程
	序：采用低电平触发方式
	ORG 0013H
	PUSH PSW
	PUSH ACC
	JNB P1.6,PDVT1
	JNB P1.5,PDVT2
	JNB P1.4,PDVT3
	JNB P1.3,PDVT4
	JNB P1.2,PDVT5
	JNB P1.1,PDVT6
	JNB P1.0,PDVT7
OUT:POP ACC
	POP PSW
	RETI
	
PDVTX:......
	LJMP OUT
	
28、在最低级中断服务中设置屏蔽字将中断允许屏蔽掉，同时采用LCALL指令调用RETI中断退出指令，以此来欺骗系统，使主程序仍然在中断服务
	中运行，系统误认为是在一个子程序中：
	PUSH IE
	MOV IE,#MASK
	LACLL OUT
TEXT:
	......中断服务
    POP IE
	RET
OUT:RETI

29、
	MOV IE,#97H
	MOV IP,#02H
	
30、TF1,TF0,IE1,IE0,RI,TI,
	TF1,TF0是计时器和计数器的中断请求标志，分别位于TCON.7和TCON.5。在计时器或计数器溢出使，由系统自动置位，当系统响应请求后可
	以由系统硬件自动清除，也能用户查询软件清除。
	IE1,IE0是外部中断的请求标志，位于TCON.3和TCON.1,当外部中断请求时，该位置位，之后由系统自动复位。
	TI为串行通讯数据发送完毕的中断请求标志，位于SCON.1，在系统发完一帧数据时置位，需要手动复位，使用CLR TI即可完成复位。
	RI是串行通讯数据接收完毕的中断请求标志，位于SCON.0，当SM2=1时，需要方式1需要等到最后一个结束位接到时才会置位，方式2和3同样
	需要等到最后一个结束位接收到时，才会置位RI，同时将结束位放置到RB8中。同样需要手动复位，CLR RI即可完成复位。
	
31、(1)都是作为定时器工作方式为方式1，16位定时器；
	(2)	T0定时器状态为25000，定时时长为50ms；T1定时器状态为4000，定时时长为8ms；
	(3)T1为高优先级，T0为低优先级；
	(4)T0-000BH;T1-001BH;
	(5)同时启动T0和T1。
```

#### 第5.5章 串口通讯

```matlab
单机-单机通讯：A主机，B从机
	1、A发送AA，等待B回复
	2、B收到信号，辨别为AA后发送回复BB，进入数据接收等待
	3、A收到回复信号后，辨别为BB，则进入数据发送状态
	4、A从指定地址开始，顺序发送数据块内的数据，每发送一个计算一下数据和
	5、B接受数据，存放在指定位置，每收到一个计算一些数据和
	6、A发送完毕，发送数据总和，并等待B回复
	7、B接受数据完毕，计算得到一个数据总和，收到A发送的数据总和，作比较
	8、经过B比较，若两者相等，回复信号00，通讯结束；若两者不等，回复信号FF，继续回到第5步。
	9、A收到回复，若为00则通讯结束；若为FF，则回到第4步。
A：
	MOV TMOD,#02H
	MOV TH1,#0F3H
	MOV TL1,#0F3H
	SETB TR1
	MOV PCON,#00H
	MOV SCON,#50H
AL1:MOV SBUF,#0AAH
AW1:JBC	TI,AR1
	SJMP AW1
AR1:MOV A,SBUF
	XRL A,#0BBH
	JNZ AL1
AL2:MOV R0,#30H
	MOV R7,#16
    MOV R6,#00H
AR2:MOV SBUF,@R0
	MOV A,R6
	ADD A,@R6
	MOV R6,A
	INC R0
AL3:JBC TI,AR3
	SJMP AL3
AR3:DJNZ R7,AR2
	MOV SBUF,R6
AL4:JBC TI,AR4
	SJMP AL4
AR4:JBC RI,AL5
	SJMP AR4
AL5:MOV A,SBUF
	JNZ AL2
AEN:RET

B:
	MOV TMOD,#02H
	MOV TH1,#0F3H
	MOV TL1,#0F3H
	SETB TR1
	MOV PCON,#00H
	MOV SCON,#50H
BL1:JBC RI,BR1
	SJMP BL1
BR1:MOV A,SBUF
	XRL A,#0AAH
	JNZ BL1
	MOV SBUF,#0BBH
BL2:JBC TI,BR2
	SJMP BL2
BR2:MOV R0,#30H
	MOV R7,#16
	MOV R6,#00H
BL3:JBC RI,BR3
	SJMP BL3
BR3:MOV A,SBUF
	MOV @R0,A
	ADD A,R6
	MOV R6,A
	INC R0
	DJNZ R7,BL3
BL4:JBC RI,BR4
	SJMP BL4
BR4:MOV A,SBUF
	XRL A,R6
	JNZ BL5
	MOV SBUF,#00H
BR5:JBC TI,BEN
	SJMP BR5
BL5:MOV SBUF,#0FFH
BR6:JBC TI,BL7
	SJMP BR6
BL7:SJMP BR2
BEN:RET

单机-多机通讯：A主机，从机地址00H,01H,10H，需采用方式2或3，因为需要借用TB8
	需要注意的是，单机对多机通讯需要按从机地址片选，因此主机需要输出的有地址信号和数据信号，为了加以区分，需要借用TB8作为标志位，
	当TB8=1时，表示目前在发送地址信号；TB8=0时表示当前在发送数据信号。
	注意，方式2和3的数据包含9位，其中第9位即为TB8上面的数据，也就是标志位。就是说主机在发送地址信号时，会连同标志位TB8上的数据
	一起发送给从机，从机会将主机的TB8放置到自己的RB8上。
	而从机确定目标是自己的方式为：首先从机会置位SM2当主机发出地址信号时，每个从机都会收到信号，当数据接收完毕RI置1时，从机进入中
	断服务，在中断服务中判断收到的地址是否与自己的地址一致，如果一致，就将自己的SM2置0。这样一来，地址匹配的从机状态为
	RB8=1,SM2=0，即在接收数据时不需要等到结束位就可申请中断；而地址不匹配的从机状态为：RB8=1,SM2=1，即接受数据时需要等待结束	
	位才能置位RI，而主机在发送数据时，TB8上的数据为0，不是结束位标志(结束位标志位1)，则无法置位RI，数据对该从机无效。
A-主机,从机B-00H,C-01H......
A:
	MOV TMOD,#02H
	MOV TH1,#0F2H
	MOV TL1,#0F2H
	SETB TR1
	MOV PCON,#00H
	MOV SCON,#0D0H (方式3，可变波特)
AL1:SETB TB8
	MOV SBUF,#01H
AR1:JBC TI,AL2
	SJMP AR1
AL2:......(传数据具体操作)
	
B:
	MOV TMOD,#02H
	MOV TH1,#0F2H
	MOV TL1,#0F2H
	SETB EA
	SETB ES
	SETB TR1
	MOV PCON,#00H
	MOV SCON,#0F0H (方式3，可变波特,SM2=1)
BL1:JBC RI,BR1
	SJMP BL1
BR1:......(存数据的具体操作)

ORG 0023H
	MOV C,RB8
	XRL C,#1
	JC NO
	MOV A,SBUF
	XRL A,#00H
	JNZ NO
	CLR SM2
NO: RETI
	
C:
	MOV TMOD,#02H
	MOV TH1,#0F2H
	MOV TL1,#0F2H
	SETB EA
	SETB ES
	SETB TR1
	MOV PCON,#00H
	MOV SCON,#0F0H (方式3，可变波特,SM2=1)
CL1:JBC RI,CR1
	SJMP CL1
CR1:......(存数据的具体操作)

ORG 0023H
	MOV C,RB8
	XRL C,#1
	JC NO
	MOV A,SBUF
	XRL A,#01H
	JNZ NO
	CLR SM2
NO: RETI
```

#### 第六章 扩展设计

```matlab
WR16:MOVX A,@DPTR
	MOV R4,A
	MOVX @R0,A
	INC DPTR
	INC R0
	CJNZ R0,#0,NEXT  不相等，则说明低位字节地址累增超出低位的范围，需要向高位进位，这个溢出不会移到C标志中
	INC P2
NEXT:DJNZ R7,WR16
	DEC R0     ;前面自增，完成时指向下一个地址空间，所以自减回到最后一个字节的地址
CHECK:
	MOVX A,@R0
	XRL A,R4
	JB  ACC.7,CHECK
	RET
	
	MOV A,#98H   A口C高4作入口，B口C低4作出口，方式0
	MOV DPTR,#7FFFH
	MOV @DPTR,A
	MOV DPTR,#7FFCH  选中A口
	MOV A,@DPTR  ;读A口数据
	MOV DPTR,#7FFDH  选中B口
	MOV @DPTR,A  ;数据送B口
	所谓出口入口是数据相对8255A芯片来说，由于8255A是由单片机控制的，所以入口既是外界将数据送入单片机的端口，用来读取数据；
	出口是单片机向外界送出数据的端口，需要将数据送到该端口。
	
	MOV P2,#7EH   ;选中RAM存储器
	MOV R0,#30H   ;片外间接寻址
	MOV A,@R0    ;读取7E30H处的数据
	
	MOV DPTR,#7EF0H
	MOVX @DPTR,A
	
	MOV DPTR,#7F04H ;指向定时器低8位
	MOV A,#18H
	MOV @DPTR,A
	INC DPTR
	MOV DPTR,#40H   ;高2位为01，为连续方波，单次方波、连续方波，单次脉冲，连续脉冲
	MOV DPTR,#7F00H
	MOV A,#0C2H    ;11000010,启动计时器，方式0，AC入，B出
	MOV DPTR,#7F01H
	MOV A,@DPTR
	INC DPTR
	MOV @DPTR,A
	
书上232页键盘程序，试着写一遍，按照键盘8行4列
KEY :CLR A
	ACALL KS
	JZ  NK
	ACALL DELAY ;调用延时子程序，这个默认有
	CLR A
	ACALL KS
	JZ  NK      ;这里是如果有键按下，先通过短暂延时，再判断一次，以去除抖动干扰
	MOV A,#0FEH ;A.0为0，其余为1，表示仅改变A.0其余不变，来判断按下的键是否在第一行
	MOV R4,#0
FIND:
	MOV R2,A
	ACALL KS
	JNZ  OUT
	INC R4
	MOV A,R2
	RL A
	CJNZ A,#0FEH,FIND
	CLR A
	SJMP NK	
OUT:SWAP A
	ADD A,R4    ;经过扫描之后，A中的低4位保存的是列序，交换到高位去，低4位变为0000，加上R4中保存的行序，即为列-行
NK: RET
	
KS: MOV DPTR,#PA
	MOV @DPTR,A
	MOV DPTR,#PC
	MOV A,@DPTR
	CPL A
	ANL A,#0FH
	RET
	
8155控制信号灯,共阴极数码管，所有位码置0则选中

DIR MOV DPTR,#CWR   ;CWR为控制端地址，即A1A0=00，CS=1
	MOV A,#4DH      ;01001101,依次01表示定时器停止，00表示中断允许控制，11表示工作方式3，PA/PC作出口，PB作入口
	MOVX @DPTR,A
	MOV R0,#DATA    ;表示数据的字符存储空间的首地址
	MOV R5,#0FEH    ;共阴极数码管，11111110表示选中最低位的数码管
	MOV R7,#4
    
    MOV A,#0FFH
    MOV DPTR,#PC
    MOVX @DPTR,A
L1: MOV A,@R0
    MOV DPTR,#TAB
  	MOVC A,@A+DPTR
  	MOV DPTR,#PA
  	MOVX @DPTR,A
  	MOV A,R5
  	MOV DPTR,#PC
  	MOVX @DPTR,A
  	RL A
  	MOV R5,A
  	LCALL DELY
  	INC R0
  	DJNZ R7,L1
  	RET
  	
DELY:MOV R6,#10
DEL1:MOV R4,#500
	 DJNZ R4,DEL1
	 DJNZ R6,DELY
	 RET
TAB:DB 3FH,........数码管数字 与对应的代码

	ORG 0000H
	MOV SP,#2FH
	MOVX DPTR,#7FFFH  ;控制命令符地址
	MOV A,#0D1H       ;11010001,110命令选择，100显示器清0，初始值为0,0表示FIFO不清，1表示总清零
	MOVX @DPTR,A
	NOP
	NOP               ;清除期间不能进行任何操作，给系统留出时间清零
LL1:MOV A,@DPTR       ;状态字的最高位DU表示是否清零完成，当清零完成时DU=0
	JB ACC.7,LL1
	MOV A,#34H        ;00110100
	MOVX @DPTR,A      ;设置时钟分频
	MOV A,#00H
	MOVX @DPTR,A      ;设置键盘屏幕状态，8左，编码，双键互锁
//以上属于初始化部分，已经完成，当前8279完成重置，20分频，双键互锁，8左	
MAIN:JB P3.2,MAIN     ;外部中断位，当按键按下时，8279会送给51一个中断请求，如果没收到则一直循环即可
	LCALL KEY
	LCALL DIR
	SJMP  MAIN
//程序主体完成，下面是具体的按键处理程序KEY以及显示处理程序DIR
KEY:MOV DPTR,#7FFFH
	MOV A,#40H        ;01000000,读取当前扫描键值的设置，表示仅读取当前位置的数据，由于存储时一直再往后推，所以只需读当前。
	MOVX @DPTR,A
	MOV DPTR,#7EFFH
	MOV A,@DPTR
	ANL A,#3FH        ;00111111去掉最高位CONL和SHIFT,使变为数字对应的扫描键值
	MOV DPTR,#TAB	  ;根据扫描键值查表选择对应的按键
	MOVC A,@A+DPTR
	CJNE A,#0AH,KEY1
	SUBB A,#0AH
	MOV  B,#03H
	MUL  AB
	MOV DPTR,#CMOTAB
	JMP @A+DPTR	
KE1:JC PDATA
CMOTAB:
	LJMP COMA1
	LJMP COMA2
CMOA1: 
	MOV R0,#70H
	MOV R2,#06H
	MOV
	
	
1、因为P0口是作为数据地址复用的I/O口，需要将地址锁存到外部锁存器之后才能进行数据的传送，否则直接传送数据会将地址信息覆盖；而P2口
	仅作为地址线，所以不需要锁存地址。
	
2、程序存储器在寻址时，51单片机通过控制PSEN信号选通程序存储器，通过控制RD信号选通数据存储器。这两个信号在时序逻辑上是不会发生冲
   突的，所以在空间寻址时也不会发生冲突竞争现象。
   
3、不能，因为P2口仅作为外部空间的高8位地址，其没有配备外部锁存器对信号进行锁存，所以在外部拓展时仅能做地址总线。

4、最大空间为64KB，并联4个64KB的存储器，额外引入2位控制信号作为片选信号，依次对应每个64KB存储器。

5、当51对外部存储器（包括数据和程序）进行读写时，使用MOVX和MOVC指令会产生ALE信号，ALE高电平时P0口为地址低8位，当ALE变为0时，
	连接外部地址锁存器使能端G，从而将地址锁存到外部存储器。
	当访问外部程序存储器时，产生PSEN信号，P0口上出现外部程序存储器的数据；
	当访问外部数据存储器时，产生RD信号、当数据送到外部数据存储器时，产生WD信号。
	
6、地址信号；
	当执行MOVX A,@DPTR时，出现的是外部ROM的程序数据；当执行MOVX @DPTR,A出现的是将要写入ROM的程序数据(针对可编程ROM)；
	MOVX指令会产生ALE指令，使得P0口地址锁存到外部；
	同时，MOVX操作对象如果是ROM，PSEN会产生信号，低电平时出现程序数据；
	如果MOVX操作对象是RAM，会产生RD和WD，对外部RAM进行读写操作。
	来源于DPTR中的DPH和DPL，分别保存外部存储空间的高8位地址与低8位地址。
	
7、三总线结构有利于用户便捷得进行拓展，结构清晰。
	线选法不适用译码器，因此连线较为简洁，结构更精简，但是线选法的拓展个数受限于引脚个数，且当出现引脚悬空时，会有地址重叠；
	部分译码相比于线选法，其同时拓展的存储器数量得到提升，但由于部分译码也会有悬空引脚，因此会出现地址混叠；
	全地址译码保证每个地址空间都有一个独立的地址编码，不会出现地址混叠现象，但是会引入较多的译码器增加了复杂性。
	
8、先是低8位地址信息，然后是具体地址空间内的数据信息；DPH和DPL。（傻逼吗一个问题一直问）

9、可以。对于RAM的读信号需要将PSEN和RD采用与门连接，这样连接可以使RAM能同时响应程序读取和数据读取。

10、P2.6与P2.5作为译码器输入端，假设三个2764分别表示为A,B,C，依次对应译码器的00,01,10。
	则三个存储器的地址空间分别为：A-0000H~1FFFH;B-2000H~3FFFH;C-4000H~5FFFH
	如果采用线选法连线，空间依次为：A-2000H~3FFFH;B-4000H~5FFFH;C-8000H~9FFFH
	
11、地址不能重叠，即把所有引脚都接上??接线时把Y0和Y1输出接与门再接到ROM上，只要有0就能选到；其余Y2,Y3分别接2个RAM即可。
	若要变成8000H~B000H,分别接Y4和Y5就可以了，C000H~FFFFH接Y6和Y7即可。
	
12、6116为2KB，若要16KB需要将8片，采用3-8译码器。设计图就地址对地址，数据对数据，P2.5/P2.4/P2.3连接译码器，输出端分别连接片
	选。6116的OE连接RD，WE连接WD。译码器使能保持畅通。锁存器E接地保持畅通，G接ALE信号，EA接地。
	多出的27128采用线选方式连接，确保在访问ROM时线选信号为0即可。
	同时ROM的OE端还要接到PSEN上。
	
13、不清楚测试的内容是啥，就以写入诊断和读出诊断为例：
	算法：往每个存储器中指定位置存入一个数据，在依次读出来，如果前后的数据一致，表明存储器的写入和读取功能完善。
	ORG 1000H
	MOV DPL,#66H
	MOV DPH,#07H      ;指向第一个6116的存储空间
	MOV R7,#8
	MOV R0,#1
L1: MOV A,R0
	MOVX @DPTR,A
	MOV A,DPH
	ADD A,#08H
	MOV DPH,A
	INC R0
	DJNZ R7,L1
	MOV A,DPH
	SUBB A,#08H
	MOV DPH,A
	DEC R0
	MOV R7,#8
L2: MOVX A,@DPTR
	XRL A,R0
	JNZ OUT
	MOV A,DPH
	SUBB A,#08H
	MOV DPH,A
	DEC R0
	DJNZ R7,L2
OUT:END
	运行结束后，R0中保存的数字大小即为出故障的存储的编号，若为0则表示所有存储器都没有问题。
	
14、因为P2口占用作为外部存储器的高8位地址总线。这样设计是为了与外部设备的高速数据传输与外部总线的正常通讯。

15、8255的A组I/O口有三种模式，包含PA口以及PC口的高4位，B组有两种模式，包括PB口以及PC口的低4位。要是联通输入输出状态来看，那就
	有3×2×2×2×2×2累计96种。
	
16、假设B口的LED灯阴极接地，阳极接到PB口
	ORG 1000H
	MOV DPTR,#7FFFH
	MOV A,#10010000B
	MOVX @DPTR,A
L1:	MOV DPTR,#7FFCH
	MOVX A,@DPTR
	JZ L1
	MOV DPTR,#7FFDH
	MOV @DPTR,A
OUT:SJMP $
	END
	
17、5部分，RAM存储器，存储数据；PA、PB、PC三个I/O口，作用就是输入输出口；定时器模块，14位减法定时/计数器。

18、
1、ORG 1000H
	MOV DPTR,#7F00H
	MOV A,#87H
	MOVX @DPTR,A
	MOV DPTR,#7F01H
	MOV A,#10101010B
	MOVX @DPTR,A
	INC DPTR
	MOV A,@DPTR
	XRL A,#10101010B
	JZ LEFT
ALL:INC DPTR
	MOV A,#0FFH
	MOVX @DPTR,A
	SJMP OUT
LEFT:
	INC DPTR
L1: MOV A,#00000001B
L2:	MOVX @DPTR,A
	RL A
	CJNE A,#01000000B,L1
	SJMP L2
OUT:SJMP $
	END
	
2、不爱搞
3、就这样了，爱咋咋地。	
```

![image-20231207212920097](/notes_images/image-20231207212920097.png)

#### 第七章 AD与DA拓展

```matlab
1、274页程序解释：在拓展的数据存储器中，保存了某个信号的一个周期的采样数字信号，累计128个数据，利用单极型DAC将数据存储器中的数据
	依次读出，再循环输出，得到指定的信号。
ORG 0H
LJMP DA0       ;DA0程序保存在程序存储器中，直接采用LJMP可以直接转移到指定位置

DA0:MOV R7,#128
	MOV DPTR,#6000H ;6000H为数据存储器的起始地址，数据存储器中的信号采用DPTR来读取，而送到DAC采用R0
	MOV P2,#0BFH
	MOV R0,#0FFH    ;因为DAC送数据只需要一个指定的位置即可，不需要频繁的增减地址，所以采用R0，选数据需要频繁变换
DA1:MOVX A,@DPTR
	MOVX @R0,A
	ACALL DELY
	INC DPTR	
	DJNZ R7,DA1
	AJMP DA0
	END
	
DELY:MOV R6,#100
L1  :MOV R5,#98		;1
	 NOP			;1
L2  :DJNZ R5,L2  	;98×2
	 DJNZ R6,L1		;2
	 RET
	 100×(2+98×2+2)=100×200=20000=20ms
	
2、276页双极型DAC做波形发生器
(1)反向锯齿波：
MSW:MOV DPTR,#0BFFFH	;0BFFFH是DAC的地址，视具体连接而定
L1: MOV R7,#80H     	;80H为双极型DAC中模拟量0对应的数字信号
L2: MOV A,R7
	MOVX @DPTR,A
	DJZN R7,L2			;从80H也就是逐步往下输出，即信号从0往-Vref/2走，输出即为斜率向下的一元函数线段
	AJMP L1				;R7见到00H后继续回到初始值80H开始重复，则输出状态为反向锯齿波
(2)正向锯齿波：同理，从80H开始往上加，直达FFH后，手动复位到80H
PSW:MOV DPTR,#0BFFFH
L1 :MOV R7,#80H
L2 :MOV A,R7
	MOVX @DPTR,A
	INC R7
	CJNE R7,#0FFH,L2
	AJMP L1
(3)双向锯齿波：同理，双向锯齿波需要涵盖正负，所以数字信号从00H增加到FFH，再复位，重复即可。（负向的从FFH减到00H即可）
DSW:MOV DPTR,#0BFFFH
	MOV R7,#00H
L1: MOV A,R7
	MOVX @DPTR,A
	INC R7
	AJMP L1				;FFH加1自动复位到00H所以不需要额外的辅助指令
(4)正三角波：类似于负锯齿和正锯齿，模拟信号从0到幅值再回到0，数字信号从80H递增到FFH再递减回到80H。
SSW:MOV DPTR,#0BFFFH
L1 :MOV R7,#80H
L2 :MOV A,R7
	MOVX @DPTR,A
	INC R7				;累加一直到FFH
	CJNE R7,#FFH,L2		;到达FFH，FFH这个点交给递减代码块绘制，直接传递到下一级
L3 :MOV A,R7
	MOVX @DPTR,A
	DEC R7				;递减R7，直到80H
	CJNE R7,#80H,L2		;80H这个点不处理，返回到递增代码块处理
	AJMP L2
(5)负三角波和正负都包含的三角波，类比与(4)的程序，只需要更改初值和阈值就可以了，省略。
(6)三角函数绘制：这个比较麻烦点，采用到单级型绘图的思想，
	要么将一个周期采样AD转换为数据，保存在数据存储区中的某区域，从区域入口开始，依次读取数据并绘图即可，读完后手动返回入口重复。
	要么将一个周期采样256次，将采样后的AD数据以表格形式保存在TAB开口的代码块中，使用查表指令，从0到255循环查表
SIN:MOV P2,#0BFH
	MOV R0,#0FFH
L1 :MOV R7,#00H
L2 :MOV A,R7
	MOV DPTR,#TAB
	MOVC A,@A+DPTR
	MOVX @R0,A
	INC R7			
	AJMP L2
TAB: DB ......
	 DB ......
	 .........	
	 
3、书上284页ADC0809的接线方式中2个或非门的作用理解：
	首先0809中的ALE接口是用来锁存通道地址CBA的，其触发方式是上升沿触发；START是启动控制，其触发方式是高电平触发；
	这2个信号都是需要单片机向0809传递的信号，所以连线时考虑与WD相关。挡51往外送数据时，WD为0，取反即可得到上升沿和一个周期的高	
	电平。恰好能先锁存输入口地址，再开始运行，时序上刚好衔接。
	OE是允许读出的控制，高电平触发，需要0809向单片机发送数据，也就是当51给出RD信号时有效即可。将RD取反后连接到OE，当51想要读取
	转换后的数据时，给出一个低电平RD，则OE就能收到高电平控制信号，控制数据输出。
	如果是只有一个0809，理论上不需要片选，所以可以不适用2.7引脚作片选，因为单纯的WD和RD已经可以完成目的；
	但是如果系统中包含多个0809，则需要采用一定的方式来实现片选（线选法、部分地址译码，全地址译码），具体思路为：通过片选线给出的
	信号能在不影响ED和RD的功能的前提下，能够实现当WD有效时能阻碍未被选中的芯片的数据传送。在本例中，通过或非门将WD和RD连接。
	在被选中的芯片中，或非门的P2.7端为0，输出取决于另一端的WD或RD，所以在任何情况下都不构成影响，被选中的芯片能够顺利运行；
	而在未被选中的芯片中，或非门的P2.7端为1，输出恒定为0，将该芯片的信息通路锁死，阻碍了WD和RD信号的传输。
	课代表：
	在单个0809中P2.7可要可不要，在多片0809中，被P2.7=0选中的芯片的两个或非门输出端取决于WD或RD的状态，因此不会对该0809芯片造
	成影响；未被选中的芯片，该片选信号为1，将或非门锁死，使输出恒定为0，有效阻碍未被选中芯片的数据传输。
	
```

![image-20231209230120885](/notes_images/image-20231209230120885.png)

```matlab
例7.2代码：
	CLR A
	MOV R2,A
	MOV R3,A
	MOV R7,#8
	MOV DPTR,#7FFFH
L1: MOVX @DPTR,A
	JB P3.2,$      ;$的意思就是跳转到自身位置
	MOVX A,@DPTR
	ADD A,R2
	MOV R2,A
	MOV A,R3
	ADDC A,R3
	MOV R3,A
	DJNZ R7,L1     ;低位加法不带进位，进位保存在C中，进位最多只有一位，所以再把进位加到高位即可。
	MOV R7,#3
L2: CLR C
	MOV A,R3
	RRC A
	MOV R3,A
	MOV A,R2
	RRC A
	MOV R2,A
	DJNZ R7,L2   ;右移3位表示除8
	MOV 7FH,A
	
红绿灯控制：以P1口控制从P2.5~P2.0依次为：南北方向GYR,东西方向GYR
	则P1口的状态变化为为0CH-30s->0AH-3s->21H-30s->11H-3s->0CH
	最简单的做法是按照顺序把流程写完再返回原始状态就好了//
	ORG 2000H
MAIN:MOV P1,#0CH
	MOV R7,#30
L1: LCALL DELY
	DJNZ R7,L1
	MOV P1,#0AH
	MOV R7,#3
L2: LCALL DELY
	DJNZ R7,L2
	MOV P1,#21H
	MOV R7,#30
L3: LCALL DELY
	DJNZ R7,L3
	MOV P1,#11H
	MOV R7,#3
L4: LCALL DELY
	DJNZ L4
	AJMP MAIN
	/*下面是延时1秒子程序，可以的话，记住*/
	ORG 5000H
DELY:MOV R1,#5		;1
DE1: MOV R2,#200	;1
DE2: MOV R3,#250	;1
DE3: NOP			;1
	 NOP			;1
	 DJNZ R3,DE3	;2
	 DJNZ R2,DE2	;2
	 DJNZ R1,DE1	;2
	 RET
	 计算时间：(((1+1+2)R3+2+1)R2+1+2)R1+2+1=3+5X(3+200X(3+250X(4)))=1,003,018≈1s
	 
灯光循环闪烁：P1口0~7分别连接LED灯的阳极端，高电平点亮
	一种思路直接：将A赋值为10000000，依次右循环移位送到P1口，然后延迟后手动给P1口全部置0，实现闪烁；
	另一种蒙版思路：将A赋值为10101010，采用一个蒙版10000000，A中值循环右移，由蒙版指定LED灯序号，两者与运算作为输出
	ORG 1000H
MAIN:MOV A,#10000000B
L2:	MOV R7,#10
L1: MOV P1,A
	LCALL DELY
	CLR P1
	LCALL DELY
	DJNZ R7,L1
	RR A
	AJMP L2
DELY:跟上边一样就OK了

两个开关K1和K2，K1按下时数码管加1，K2按下时数码管减1，中断实现
数码管连接到P1口，K1接反相器再接INT0,K2接反相器再接INT1，另一端都接上拉电阻。则按下时，外部中断收到0信号，开始中断进程：
	ORG 0003H
	MOV A,P1
	INC A
	MOV P1,A
	
```

