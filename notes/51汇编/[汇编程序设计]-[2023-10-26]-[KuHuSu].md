### 一、伪指令

```java
1、ORG指令：程序的起始地址，指定程序从哪个地址开始寻址。一个源程序可以有多个不同的ORG，表示程序存储在不同位置。
    ORG 8000H
    
2、END：程序终止指令，一个源程序只能有一个END。
    END
3、DB：（datablock：数据块）从指定位置开始顺序存放多个数据；单字节。
    ORG 8000H
    TAB: DB 74H，73,101B
    表示从8000H这个位置开始，依次存放三个数据，分别是：
        74H；
        73（十进制）转化为16进制为49H；
        101B（二进制）转化为16进制05H。
    这三个数据构成的数据块统称为TAB，后续引用就可以直接使用TAB引用。
4、DW：同上面的DB，只不过DW存放的是双字节数据，不足的用高位00H补齐，每两个字节顺序存储。
5、DS：从指定位置跳转指定长度：
        ORG 8000H
        DS  08H
        DB  55H，45H
        表示从8000H开始，跳转8格，到8008H，8000H~8007H空置备用，从8008H开始依次填入55H和45H。
6、EQU：等值指令
        AA EQU R6
        类似于C语言中的宏，可以把汇编符号或者特殊的数据用一个字符串代替，程序在运行时优先将代替的替换回来，再编程。
7、DATA：与等值相似，将特定的地址赋予特定的字符串，后续使用该字符串自动替换为其等值的地址。
        ABCD DATA 8096H
        表示ABCD这个字符串代表的含义就是8096H这个地址。
8、BIT：与DATA相似，但用作位地址的赋值：
        A1 BIT P1.0
        A2 BIT P2.0
	
```

### 二、51的寻址方式

```java
1、立即寻址：
    相当于不需要去按地址寻找数据，而是把数据直接就放在操作码后边，直接对数据进行操作。这个直接操作的数据叫做立即数，所以叫做立即寻址。
    操作码 立即数
    51中立即数的表示采用#30H表示，如果只有30H则表示30H这个地址。
2、直接寻址：
    操作码后面跟一个地址，按照这个地址去进行下一步操作
    MOV 30H,#30H
    表示将30H这个立即数移动到30H的位置存储。第一个30H是指地址，第二个是立即数。
3、寄存器寻址：
    将数据存放在工作寄存器中，使用该寄存器的代号来直接找到寄存器中保存的数据：
    MOV A,R3；
    表示将寄存器R3中的数据放到A中，这里的R3也可以使用R3的物理地址即03H（以第一区为例），相当于在寄存器的基础上进行立即寻址。
4、寄存器间接寻址：
    同样用寄存器，如果寄存器中存放的是数据的地址，则称为寄存器间接寻址：
	与寄存器直接寻址不同的是，间接寻址时能够采用的寄存器只有R0和R1，其他6个寄存器不用做间接寻址；
    访问内部时能用作间接寻址的寄存器包括：@R0,@R1,SP
    访问外部时能用做间接寻址的寄存器包括：@R0,@R1,@DPTR
    MOV @R0,A
    表示将A中的数据移放到寄存器R0中保存的地址中去；
    MOV A,@R0
    表示将R0中的地址指向的位置上的数据移放到A中；
    MOVX A,@DPTR
    表示将DPTR中的地址指向的外部存储器中的位置上的数据移放到A中；
5、基址寄存器加变址寄存器间接寻址（51指令系统独有的寻址方式）
    如果我需要查看的数据从0240H开始，依次往后，每隔两个位置读取一个数据。
    那就可以采用基址＋变址的方式进行寻址；将遍历的起始地址存放在DPTR或者PC中，将变址存放在寄存器A中
    MOV A,#02H
    MOV DPTR,#0240H;这里虽然存放的是一个立即数，但实际代表的是0240H这个地址作为基址；
    MOVC A,@DPTR+A;表示将DPTR中的地址加上A中的地址，得到一个新的地址，即0240H+02H=0242H。
        将这个地址位置上保存的数据移到A中。
    因为这也算是一种间接的寻址方式，所以同样需要采用@引导。
6、相对寻址：
    特指相对于PC寄存器寻址，不同于基址＋变址的寻址方式，当PC运行完某个程序后，以当前的PC位置为基础，添加一个偏移量rel；
    将PC的顺序强行移动到当前位置+rel位置上。
        ORG 2000H
        JNZ 23H；判断A是否等于0，若为0则转移。
    计算转移位置的方法：起始位置+操作码的指令长度+偏移量rel：2000+2+23=2025H
        表示如果A中的数据为0，则直接执行2025H位置上的程序，实现程序的跳转。
7、位寻址：
   位寻址空间为RAM中20H~2FH的空间128个位置，以及SFR中的93个可位寻址的空间，总计221个可位寻址的位置。
```

### 三、数据传输类的指令

```java
1、MOV格式：MOV <目标字节>，<源字节> ；片内的数据传送，包含以下16种类型：
    MOV A,#DATA;
	MOV A,R1;
	MOV A,30H;
	MOV A,@R0;

	MOV R3,#56H;
	MOV R3,A;
	MOV R3,30H;
(这里没有寄存器送寄存器的指令)

	MOV 30H,#30H;
	MOV 30H,A;
	MOV 30H,R3;
	MOV 30H,@R0;

	MOV @R0,#DATA;
	MOV @R0,30H;
	MOV @R0,A;
	MOV @R0,P1;（这个是将外部输送到P1.0~P1.7的数据保存到寄存器R0指向的地址位置，属于间接寻址）

	MOV DPTR,#0250H;（DPTR是双字节寄存器，所以要存入一个4位16进制数据）
	
    目标字节可以是累加器A，寄存器R0~7，寄存器间接寻址的R0和R1，直接地址以及外部地址寄存器DPTR；
    源字节可以是立即数，直接地址，累加器A，寄存器R1~7，间接寻址寄存器R0和R1，以及I/O口线。
	注意一个点：没有寄存器送寄存器的指令。
    
2、MOVX：其格式与MOV一致，但仅用作访问外部存储器，主要有以下4种类型：
    MOVX A,@R0;(将R0中存放的外部存储器地址位置上的数据移动到A中)
	MOVX @R0,A;
	MOVX A,@DPTR;
	MOVX @DPTR,A;(A中数据送到DPTR中地址指向的外部存储器位置上)

3、MOVC:同样格式与MOV相同，特指采用基址＋变址寻址方式寻址的指令，所以只有2种类型：
    MOVC A,@A+DPTR;
	MOVC A,@A+PC;
	分别表示采用DPTR和PC作为基址，且目前看来，貌似不能反向传输，不能将A中的东西送达基址+变址位置上。
   
4、交换指令，5条：
    XCH A,R3;
	XCH A,30H;
	XCH A,@R0;
	分别表示将累加器A中的内容与寄存器R3中的内容、直接地址指向位置上的内容、间接寻址寄存器指向地址位置上的内容互换；
    
    XCHD A,@R0;将A中内容与间接寻址R0中地址位置上的内容的低4位进行交换，只交换低4位，高4位不影响。
    SWAP A;将A中内容的高4位与低4位数据进行互换。
   
5、堆栈指令，2条
    MOV SP,#60H;将堆栈的栈底地址置为60H
    PUSH 30H;将30H位置上的数据放入SP+1的位置上；
    PUSH 31H;同上，SP+1；
    POP  30H；将当前SP指向的位置，也就是62H上的数据，拿出来放到30H所指向的位置，同时堆栈指针SP-1=61H，指向堆栈顶部。
    堆栈相当于在RAM区30H~7FH的范围内，指定从某个位置开始，开辟一块地址空间，用来暂存某些数据，SP指针在复位后指向07H。
     
    总计16+4+2+5+2 = 29条指令
```

### 四、算数运算指令

```java
1、ADD:加法运算，计算结果不带进位，包含以下4种类型：
    ADD A,#30H;
	ADD A,R3;
	ADD A,@R0;
	ADD A,30H;
	表示将立即数、寄存器内容、寄存器指向的内容、直接地址上的内容加到累加器A中，计算过程不加进位CY，但是计算的结果会对程序状态字		PSW中的CY、AC、OV以及P四位数据带去影响：
        高位进位：CY置1，否则为0；
        低四位进位，AC置1，否则为0；
        第6位进位与第7位进位结果取异或为OV；

2、ADDC:加法计算，计算过程考虑当前PSW中的进位CY位置上的数据。同样包含4条
    ADDC A,#30H;计算过程为（A）+30H+CY，CY＝0 等同于ADD
	ADDC A,R3;
	ADDC A,@R0;
	ADDC A,30H;
        
3、INC：自身加1，增1的对象有5类：
    INC A;
	INC R3;
	INC @R0;
	INC 30H;
	INC DPTR;表明DPTR = DPTR + 1相当于C中的i++。
   
4、DA：十进制调整
    51在计算加法的过程中，如果输入的两个16进制数不包含大于9的部分，比如36H和37H，在计算的过程中，仍然是按照2进制加法的方式计算		得出的结果，这个结果是6DH。但是按照我们习惯的思维来看，36+37=73，这是以十进制的思维来看的。DA指令能够将计算得到的16进制结	果，转化为我们熟知的十进制结果，也便于观察。计算的方式就是将十进制8421BCD码中，非法的部分即A~F的部分进行循环替换，替换的规	  则为将9以上的数据增加6H（16-10=6），如果出现在十位上则加60H。
    MOV A,#6DH
    DA A；结果为低位有非法字符，加6H＝73H
    具体规则：
        （1）低位有非法字符或者AC=1，则整体加06H；
        （2）高位有非法字符或者CY=1，则整体加60H；
        
5、SUBB：减法运算与加法运算不同的是，不再区分是否减去借位，SUBB指令都需要减去借位数据CY，同样4条：
    SUBB A,#30H;
	SUBB A,R3;
	SUBB A,@R0;
	SUBB A,30H;
	表示累加器A-#30H-CY
      
6、DEC：自减，同自增INC，但不包含DPTR
    DEC A;
    DEC R3;
	DEC @R0;
	DEC 30H;表明(30H) = (30H) - 1相当于C中的i--。
        
7、MUL:乘法运算
    MUL AB;这里注意A和B之间是没有间隔的
	表示将累加器A中的数据与次累加器B中的数据相乘，得到的数据的高8位存放在B中，低8位存放在A中
   （因为结果可能小于8位，所以从A开始存放，方便后续进一步处理）
    PSW中的OV位，除了能在加法运算中作指示外，在乘法运算中，
    若结果超出8位的范围（0~255,00H~FFH），则OV置1，其余置0。CY则一直为0。
        
8、DIV：除法运算
     DIV A B;这里A和B之间是有间隔的，表示A/B
     得到的结果中，商放入A中，余数放入B中。（因为更多时候需要利用的是商）
     CY一直置0。只有当除数B中的数据为0时，OV置1，表示除法不合法。
         
     总计4+4+5+1+4+4+1+1 = 24条
```

### 五、逻辑运算指令

```java
1、ANL:AND LOGIC 与逻辑运算，有6条；
	ANL A,#00H;
	ANL A,R3;
	ANL A,@R0;
	ANL A,00H;
	ANL 30H,A;
	ANL 30,#FFH
	逻辑运算的目标字节就不包含间接寻址和片外寻址了，仅包含累加器和直接地址。
	
2、ROL:OR LOGIC 或逻辑运算，同ANL，6条：
    ORL A,#00H;
	ORL A,R3;
	ORL A,@R0;
	ORL A,00H;
	ORL 30H,A;
	ORL 30,#FFH
        
3、XRL:异或 logic，同ANL共6条：（相同出0，不同出1）
    XRL A,#00H;
	XRL A,R3;
	XRL A,@R0;
	XRL A,00H;
	XRL 30H,A;
	XRL 30,#FFH
        
    ANL A,#0FH;A与00001111作与操作，则高4为清零，低4位不变
	ANL P1,#0F0H;P1与000011110000作与操作，则低4为清零，高4位不变
	ORL P1,A;两者取或操作，就能将A的低4位填充到P1口的高4位上，而对P1口的其他位置不造成影响。
        
4、CLR:CLEAR 清零
    CLR A;将累加器A中的数据清0；
    CLR C;将进位CY中的数据清0；
        
5、CPL:opposition,取对立逻辑，按位取反：
    CPL A;若A = 11110000，按位取反得到00001111；
        
6、RL:remove left 循环左移
    RL A；若A=11110001，RL后变为11100011，高位补齐低位，循环系统中有8位数据

7、RLC:包含高位进位的左移，若CY＝1，则左移后，低为1(注意与CLR区分，CLR为clear指令为清0)
    RLC A;若A=11110000，CY=1,RLC后变为11100001，循环系统中有9位数据
   
8、RR:循环右移，逻辑同左移，方向相反。
    RR A;

9、RRC:带进位的循环右移，逻辑同左移，方向相反。
    RRC A;

左移低位补0,相当于乘2；右移高位补0，相当于除2；
```

### 六、控制转移指令

```java
1、LJMP:LONG JAMP 可以实现长距离跳转，给定一个地址，PC的指令直接跳转到指定地址，所以寻址空间64KB，地址长度两个字节。
	LJMP 6666H;指PC端指向的地址，直接跳转到6666H执行该位置上的程序。
    
2、AJMP:绝对转移，或者从模型上来看可以叫做局部转移。
    片内ROM程序存储器总共64KB，为了不造成混乱以及充分利用存储空间，可以将64KB空间划分为32片区域，那么每片区域的空间就是2KB，即	 11位二进制的寻址空间，这2KB的空间又可以划分为8页，每页包含256个位置。那么就可以把16地址位划分为5+3+8，高5位指定某片选区，	  中间3位指定某页，最后8位就能确定目标地址的位置。
    且每页的AJMP的操作码并不是完全一样，存在差异。    
	0474H化为2进制为0000 0100 0111 0100 ，前5位00000表示位置在1区，中间3位100表示第4页，后面8位74H表示具体位置。
    综合下来表示：程序跳转到第0区第4页的74H地址处的程序。
    而实际在用的时候，只需要给定页数与位置就可以了，区号包含在AJMP中，即：
    AJMP addr11;接11位的地址就可以实现绝对转移，只在当前运行的区内转移。
        
3、SJMP:SMALL JAMP短距离转移，采用短距离偏移量rel
    SJMP rel;
	同样在计算跳转目标时，要算上指令本省占据呃长度2字节，即SJMP之前的PC位置+2+rel=目标位置。
        
4、JMP:间接长转移,相当于将长转移的目标地址采用基址加变址的方式给出：
    JMP @A+DPTR;

5、JZ:累加器A为0则跳转程序
    JZ rel；
    这里的目标地址仍然是由当前位置+指令长度+偏移量的方式给出。
   
6、JNZ:NOT ZERO 累加器A不为0则跳转，跳转逻辑同JZ
    JNZ rel；
   
7、CJNE：NOT EQUAL 两个内容不相等则转移，转移的逻辑同JZ
    CJNE A,#DATA,rel;
	CJNE R3,#DATA,rel;
	CJNE @R0,#DATA,rel;
	CJNE A,30H,rel;
	需要注意的是，CJNE指令的长度为3字节，所以在计算目标地址的时候 要+3
  
8、DJNZ:delete not zero自减之后不为0则跳转（大于1则跳转）
    DJNZ R3,rel;
	DJNZ 30H,rel;

9、LCALL：长距离调用指令，寻址空间也是64KB，程序运行的结果同样是程序跳转到指定位置运行。但是与LJMP不一样的是，对于当前的程序位	  置，LJMP指令不会保存，而LCALL指令会自动的将当前程序位置暂时存入堆栈中，先存低8位，再存高8位，即最终SP指向高八位地址。
    LCALL 6666H;也是一个3字节指令，计算目标位置+3；
        
10、ACALL:绝对调用，格式同AJMP，指令顺序同LCALL。
    ACALL addr11;11位地址表示页数与具体位置。
        
11、RET:return子程序返回，上面的LCALL调用其他位置的某个程序，该程序执行结束之后，采用RET指令，将SP中的断点地址取出，重新运行主	  程序。
    RET
  
12、RETI:return I中断返回，同样是主程序断点到其他程序运行，该程序运行结束之后，返回主程序继续主程序运行，但不同的是，RETI会将     控制中断优先级的一些参数清零，此时主程序将会开放对其他优先级比较低的中断的申请。
    RETI

13、NOP:空操作，占用一个机器周期，PC+1，不做其他任何操作，用来延时或等待其他程序运行
    NOP
    
    总计17条。
```

### 七、布尔处理指令

```java
位操作的寻址空间主要包含RAM中20H~2FH的空间，总计4位地址，每个地址8位数据，总计128位，以及SFR中的部分空间，累计93位，合计221位可位寻址。而RAM中的位寻址空间的位地址编号又为00H~7FH，在寻址的时候，如果给定的位地址在00H到7FH之间，则按RAM中的位空间处理，若超过了7FH则按SFR中的位空间处理，但有可能不响应或无意义。
1、MOV:布尔传送
    MOV C,03H;将位地址为03H的数据（0或1）传递给进位标志C;
	MOV 03H,C;

2、CLR:布尔清零
    CLR C;
	CLR 03H;

3、SETB:布尔置位（置1）
    SETB C;
	SETB 03H;

4、CPL:进位取反
    CPL C;或者/C
	CPL 03H;或者/03H

5、ANL、ORL、XRL同上字节处理的逻辑关系，在位处理中，/30H表示取反，将03H地址处的数据取反。
        
6、JC:不同与JZ，JC表示进位C为1则则跳转，跳转的逻辑仍然采用rel偏移
    JC rel;

7、JNC:进位C不为1，即进位为0则转移，与JNZ刚好相反
    JNC rel;

8、JB:相比于JC，JB表示对直接位地址进行判断，若直接位地址的数据为1，则转移；
    JB 03H,rel;

9、JNB:直接寻址位为0则转移
    JNB 03H，rel;

10、JBC:直接位为1则转移，并且执行CLR操作将直接位清0；
    JBC 03H，rel;

judge：判断
```

